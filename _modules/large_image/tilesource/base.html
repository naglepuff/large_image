<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>large_image.tilesource.base &mdash; large_image  documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> large_image
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../tilesource_options.html">Tile Source Options</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../config_options.html">Configuration Options</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../image_conversion.html">Image Conversion</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../upgrade.html">Upgrading from Previous Versions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../large_image/modules.html">large_image</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../large_image_source_bioformats/modules.html">large_image_source_bioformats</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../large_image_source_deepzoom/modules.html">large_image_source_deepzoom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../large_image_source_dummy/modules.html">large_image_source_dummy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../large_image_source_gdal/modules.html">large_image_source_gdal</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../large_image_source_mapnik/modules.html">large_image_source_mapnik</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../large_image_source_nd2/modules.html">large_image_source_nd2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../large_image_source_ometiff/modules.html">large_image_source_ometiff</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../large_image_source_openjpeg/modules.html">large_image_source_openjpeg</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../large_image_source_openslide/modules.html">large_image_source_openslide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../large_image_source_pil/modules.html">large_image_source_pil</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../large_image_source_test/modules.html">large_image_source_test</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../large_image_source_tiff/modules.html">large_image_source_tiff</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../large_image_converter/modules.html">large_image_converter</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../large_image_tasks/modules.html">large_image_tasks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../girder_large_image/modules.html">girder_large_image</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../girder_large_image_annotation/modules.html">girder_large_image_annotation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../annotations.html">Annotation Schema</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../development.html">Developer Guide</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">large_image</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../index.html">Module code</a> &raquo;</li>
          <li><a href="../tilesource.html">large_image.tilesource</a> &raquo;</li>
      <li>large_image.tilesource.base</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for large_image.tilesource.base</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">io</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">pathlib</span>
<span class="kn">import</span> <span class="nn">tempfile</span>
<span class="kn">import</span> <span class="nn">threading</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">PIL</span>
<span class="kn">import</span> <span class="nn">PIL.Image</span>
<span class="kn">import</span> <span class="nn">PIL.ImageColor</span>
<span class="kn">import</span> <span class="nn">PIL.ImageDraw</span>

<span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">config</span><span class="p">,</span> <span class="n">exceptions</span>
<span class="kn">from</span> <span class="nn">..cache_util</span> <span class="kn">import</span> <span class="n">getTileCache</span><span class="p">,</span> <span class="n">methodcache</span><span class="p">,</span> <span class="n">strhash</span>
<span class="kn">from</span> <span class="nn">..constants</span> <span class="kn">import</span> <span class="p">(</span><span class="n">TILE_FORMAT_IMAGE</span><span class="p">,</span> <span class="n">TILE_FORMAT_NUMPY</span><span class="p">,</span> <span class="n">TILE_FORMAT_PIL</span><span class="p">,</span>
                         <span class="n">SourcePriority</span><span class="p">,</span> <span class="n">TileInputUnits</span><span class="p">,</span> <span class="n">TileOutputMimeTypes</span><span class="p">,</span>
                         <span class="n">TileOutputPILFormat</span><span class="p">,</span> <span class="n">dtypeToGValue</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">.tiledict</span> <span class="kn">import</span> <span class="n">LazyTileDict</span>
<span class="kn">from</span> <span class="nn">.utilities</span> <span class="kn">import</span> <span class="p">(</span><span class="n">_encodeImage</span><span class="p">,</span> <span class="n">_gdalParameters</span><span class="p">,</span>  <span class="c1"># noqa: F401</span>
                        <span class="n">_imageToNumpy</span><span class="p">,</span> <span class="n">_imageToPIL</span><span class="p">,</span> <span class="n">_letterboxImage</span><span class="p">,</span> <span class="n">_vipsCast</span><span class="p">,</span>
                        <span class="n">_vipsParameters</span><span class="p">,</span> <span class="n">dictToEtree</span><span class="p">,</span> <span class="n">etreeToDict</span><span class="p">,</span>
                        <span class="n">nearPowerOfTwo</span><span class="p">)</span>


<div class="viewcode-block" id="TileSource"><a class="viewcode-back" href="../../../large_image/large_image.tilesource.html#large_image.tilesource.base.TileSource">[docs]</a><span class="k">class</span> <span class="nc">TileSource</span><span class="p">:</span>
    <span class="c1">#: Name of the tile source</span>
    <span class="n">name</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1">#: A dictionary of known file extensions and the ``SourcePriority`` given</span>
    <span class="c1">#: to each.  It must contain a None key with a priority for the tile source</span>
    <span class="c1">#: when the extension does not match.</span>
    <span class="n">extensions</span> <span class="o">=</span> <span class="p">{</span>
        <span class="kc">None</span><span class="p">:</span> <span class="n">SourcePriority</span><span class="o">.</span><span class="n">FALLBACK</span>
    <span class="p">}</span>

    <span class="c1">#: A dictionary of common mime-types handled by the source and the</span>
    <span class="c1">#: ``SourcePriority`` given to each.  This are used in place of or in</span>
    <span class="c1">#: additional to extensions.</span>
    <span class="n">mimeTypes</span> <span class="o">=</span> <span class="p">{</span>
        <span class="kc">None</span><span class="p">:</span> <span class="n">SourcePriority</span><span class="o">.</span><span class="n">FALLBACK</span>
    <span class="p">}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;JPEG&#39;</span><span class="p">,</span> <span class="n">jpegQuality</span><span class="o">=</span><span class="mi">95</span><span class="p">,</span> <span class="n">jpegSubsampling</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                 <span class="n">tiffCompression</span><span class="o">=</span><span class="s1">&#39;raw&#39;</span><span class="p">,</span> <span class="n">edge</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the tile class.</span>

<span class="sd">        :param jpegQuality: when serving jpegs, use this quality.</span>
<span class="sd">        :param jpegSubsampling: when serving jpegs, use this subsampling (0 is</span>
<span class="sd">            full chroma, 1 is half, 2 is quarter).</span>
<span class="sd">        :param encoding: &#39;JPEG&#39;, &#39;PNG&#39;, &#39;TIFF&#39;, or &#39;TILED&#39;.</span>
<span class="sd">        :param edge: False to leave edge tiles whole, True or &#39;crop&#39; to crop</span>
<span class="sd">            edge tiles, otherwise, an #rrggbb color to fill edges.</span>
<span class="sd">        :param tiffCompression: the compression format to use when encoding a</span>
<span class="sd">            TIFF.</span>
<span class="sd">        :param style: if None, use the default style for the file.  Otherwise,</span>
<span class="sd">            this is a string with a json-encoded dictionary.  The style can</span>
<span class="sd">            contain the following keys:</span>

<span class="sd">                :band: if -1 or None, and if style is specified at all, the</span>
<span class="sd">                    greyscale value is used.  Otherwise, a 1-based numerical</span>
<span class="sd">                    index into the channels of the image or a string that</span>
<span class="sd">                    matches the interpretation of the band (&#39;red&#39;, &#39;green&#39;,</span>
<span class="sd">                    &#39;blue&#39;, &#39;gray&#39;, &#39;alpha&#39;).  Note that &#39;gray&#39; on an RGB or</span>
<span class="sd">                    RGBA image will use the green band.</span>
<span class="sd">                :frame: if specified, override the frame value for this band.</span>
<span class="sd">                    When used as part of a bands list, this can be used to</span>
<span class="sd">                    composite multiple frames together.  It is most efficient</span>
<span class="sd">                    if at least one band either doesn&#39;t specify a frame</span>
<span class="sd">                    parameter or specifies the same frame value as the primary</span>
<span class="sd">                    query.</span>
<span class="sd">                :framedelta: if specified and frame is not specified, override</span>
<span class="sd">                    the frame value for this band by using the current frame</span>
<span class="sd">                    plus this value.</span>
<span class="sd">                :min: the value to map to the first palette value.  Defaults to</span>
<span class="sd">                    0.  &#39;auto&#39; to use 0 if the reported minimum and maximum of</span>
<span class="sd">                    the band are between [0, 255] or use the reported minimum</span>
<span class="sd">                    otherwise.  &#39;min&#39; or &#39;max&#39; to always uses the reported</span>
<span class="sd">                    minimum or maximum.</span>
<span class="sd">                :max: the value to map to the last palette value.  Defaults to</span>
<span class="sd">                    255.  &#39;auto&#39; to use 0 if the reported minimum and maximum</span>
<span class="sd">                    of the band are between [0, 255] or use the reported</span>
<span class="sd">                    maximum otherwise.  &#39;min&#39; or &#39;max&#39; to always uses the</span>
<span class="sd">                    reported minimum or maximum.</span>
<span class="sd">                :palette: a list of two or more color strings, where color</span>
<span class="sd">                    strings are of the form #RRGGBB, #RRGGBBAA, #RGB, #RGBA.</span>
<span class="sd">                :nodata: the value to use for missing data.  null or unset to</span>
<span class="sd">                    not use a nodata value.</span>
<span class="sd">                :composite: either &#39;lighten&#39; or &#39;multiply&#39;.  Defaults to</span>
<span class="sd">                    &#39;lighten&#39; for all except the alpha band.</span>
<span class="sd">                :clamp: either True to clamp (also called clip or crop) values</span>
<span class="sd">                    outside of the [min, max] to the ends of the palette or</span>
<span class="sd">                    False to make outside values transparent.</span>

<span class="sd">            Alternately, the style object can contain a single key of &#39;bands&#39;,</span>
<span class="sd">            which has a value which is a list of style dictionaries as above,</span>
<span class="sd">            excepting that each must have a band that is not -1.  Bands are</span>
<span class="sd">            composited in the order listed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">getConfig</span><span class="p">(</span><span class="s1">&#39;logger&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache_lock</span> <span class="o">=</span> <span class="n">getTileCache</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">tileWidth</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tileHeight</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">levels</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sizeX</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sizeY</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_styleLock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">RLock</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bandRanges</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">if</span> <span class="n">encoding</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">TileOutputMimeTypes</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid encoding &quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span> <span class="n">encoding</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">encoding</span> <span class="o">=</span> <span class="n">encoding</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">jpegQuality</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">jpegQuality</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">jpegSubsampling</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">jpegSubsampling</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tiffCompression</span> <span class="o">=</span> <span class="n">tiffCompression</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edge</span> <span class="o">=</span> <span class="n">edge</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_jsonstyle</span> <span class="o">=</span> <span class="n">style</span>
        <span class="k">if</span> <span class="n">style</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">style</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">style</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">style</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">TileSourceError</span><span class="p">(</span><span class="s1">&#39;Style is not a valid json object.&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="TileSource.getLRUHash"><a class="viewcode-back" href="../../../large_image/large_image.tilesource.html#large_image.tilesource.base.TileSource.getLRUHash">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">getLRUHash</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a string hash used as a key in the recently-used cache for tile</span>
<span class="sd">        sources.</span>

<span class="sd">        :returns: a string hash value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">strhash</span><span class="p">(</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;encoding&#39;</span><span class="p">,</span> <span class="s1">&#39;JPEG&#39;</span><span class="p">),</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;jpegQuality&#39;</span><span class="p">,</span> <span class="mi">95</span><span class="p">),</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;jpegSubsampling&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;tiffCompression&#39;</span><span class="p">,</span> <span class="s1">&#39;raw&#39;</span><span class="p">),</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;edge&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span>
            <span class="s1">&#39;__STYLESTART__&#39;</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;style&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="s1">&#39;__STYLEEND__&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="TileSource.getState"><a class="viewcode-back" href="../../../large_image/large_image.tilesource.html#large_image.tilesource.base.TileSource.getState">[docs]</a>    <span class="k">def</span> <span class="nf">getState</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a string reflecting the state of the tile source.  This is used</span>
<span class="sd">        as part of a cache key when hashing function return values.</span>

<span class="sd">        :returns: a string hash value of the source state.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_classkey&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_classkey</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">,</span><span class="si">%s</span><span class="s1">,</span><span class="si">%s</span><span class="s1">,</span><span class="si">%s</span><span class="s1">,</span><span class="si">%s</span><span class="s1">,__STYLESTART__,</span><span class="si">%s</span><span class="s1">,__STYLEEND__&#39;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">encoding</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">jpegQuality</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">jpegSubsampling</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tiffCompression</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">edge</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_jsonstyle</span><span class="p">)</span></div>

<div class="viewcode-block" id="TileSource.wrapKey"><a class="viewcode-back" href="../../../large_image/large_image.tilesource.html#large_image.tilesource.base.TileSource.wrapKey">[docs]</a>    <span class="k">def</span> <span class="nf">wrapKey</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a key for a tile source and function parameters that can be used</span>
<span class="sd">        as a unique cache key.</span>

<span class="sd">        :param args: arguments to add to the hash.</span>
<span class="sd">        :param kwaths: arguments to add to the hash.</span>
<span class="sd">        :returns: a cache key.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">strhash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getState</span><span class="p">())</span> <span class="o">+</span> <span class="n">strhash</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_calculateWidthHeight</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">regionWidth</span><span class="p">,</span> <span class="n">regionHeight</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a source width and height and a maximum destination width and/or</span>
<span class="sd">        height, calculate a destination width and height that preserves the</span>
<span class="sd">        aspect ratio of the source.</span>

<span class="sd">        :param width: the destination width.  None to only use height.</span>
<span class="sd">        :param height: the destination height.  None to only use width.</span>
<span class="sd">        :param regionWidth: the width of the source data.</span>
<span class="sd">        :param regionHeight: the height of the source data.</span>
<span class="sd">        :returns: the width and height that is no larger than that specified</span>
<span class="sd">                  and preserves aspect ratio, and the scaling factor used for</span>
<span class="sd">                  the conversion.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">regionWidth</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">regionHeight</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
        <span class="c1"># Constrain the maximum size if both width and height weren&#39;t</span>
        <span class="c1"># specified, in case the image is very short or very narrow.</span>
        <span class="k">if</span> <span class="n">height</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">width</span><span class="p">:</span>
            <span class="n">width</span> <span class="o">=</span> <span class="n">height</span> <span class="o">*</span> <span class="mi">16</span>
        <span class="k">if</span> <span class="n">width</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">height</span><span class="p">:</span>
            <span class="n">height</span> <span class="o">=</span> <span class="n">width</span> <span class="o">*</span> <span class="mi">16</span>
        <span class="k">if</span> <span class="n">width</span> <span class="o">*</span> <span class="n">regionHeight</span> <span class="o">&gt;</span> <span class="n">height</span> <span class="o">*</span> <span class="n">regionWidth</span><span class="p">:</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">regionHeight</span><span class="p">)</span> <span class="o">/</span> <span class="n">height</span>
            <span class="n">width</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">regionWidth</span> <span class="o">*</span> <span class="n">height</span> <span class="o">/</span> <span class="n">regionHeight</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">regionWidth</span><span class="p">)</span> <span class="o">/</span> <span class="n">width</span>
            <span class="n">height</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">regionHeight</span> <span class="o">*</span> <span class="n">width</span> <span class="o">/</span> <span class="n">regionWidth</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">scale</span>

    <span class="k">def</span> <span class="nf">_scaleFromUnits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span> <span class="n">units</span><span class="p">,</span> <span class="n">desiredMagnification</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get scaling parameters based on the source metadata and specified</span>
<span class="sd">        units.</span>

<span class="sd">        :param metadata: the metadata associated with this source.</span>
<span class="sd">        :param units: the units used for the scale.</span>
<span class="sd">        :param desiredMagnification: the output from getMagnificationForLevel</span>
<span class="sd">            for the desired magnification used to convert mag_pixels and mm.</span>
<span class="sd">        :param kwargs: optional parameters.</span>
<span class="sd">        :returns: (scaleX, scaleY) scaling parameters in the horizontal and</span>
<span class="sd">            vertical directions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">scaleX</span> <span class="o">=</span> <span class="n">scaleY</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">units</span> <span class="o">==</span> <span class="s1">&#39;fraction&#39;</span><span class="p">:</span>
            <span class="n">scaleX</span> <span class="o">=</span> <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;sizeX&#39;</span><span class="p">]</span>
            <span class="n">scaleY</span> <span class="o">=</span> <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;sizeY&#39;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">units</span> <span class="o">==</span> <span class="s1">&#39;mag_pixels&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">desiredMagnification</span> <span class="ow">or</span> <span class="p">{})</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;scale&#39;</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;No magnification to use for units&#39;</span><span class="p">)</span>
            <span class="n">scaleX</span> <span class="o">=</span> <span class="n">scaleY</span> <span class="o">=</span> <span class="n">desiredMagnification</span><span class="p">[</span><span class="s1">&#39;scale&#39;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">units</span> <span class="o">==</span> <span class="s1">&#39;mm&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="p">(</span><span class="n">desiredMagnification</span> <span class="ow">or</span> <span class="p">{})</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;scale&#39;</span><span class="p">)</span> <span class="ow">or</span>
                    <span class="ow">not</span> <span class="p">(</span><span class="n">desiredMagnification</span> <span class="ow">or</span> <span class="p">{})</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;mm_x&#39;</span><span class="p">)</span> <span class="ow">or</span>
                    <span class="ow">not</span> <span class="p">(</span><span class="n">desiredMagnification</span> <span class="ow">or</span> <span class="p">{})</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;mm_y&#39;</span><span class="p">)):</span>
                <span class="n">desiredMagnification</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNativeMagnification</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">desiredMagnification</span><span class="p">[</span><span class="s1">&#39;scale&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="p">(</span><span class="n">desiredMagnification</span> <span class="ow">or</span> <span class="p">{})</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;scale&#39;</span><span class="p">)</span> <span class="ow">or</span>
                    <span class="ow">not</span> <span class="p">(</span><span class="n">desiredMagnification</span> <span class="ow">or</span> <span class="p">{})</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;mm_x&#39;</span><span class="p">)</span> <span class="ow">or</span>
                    <span class="ow">not</span> <span class="p">(</span><span class="n">desiredMagnification</span> <span class="ow">or</span> <span class="p">{})</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;mm_y&#39;</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;No mm_x or mm_y to use for units&#39;</span><span class="p">)</span>
            <span class="n">scaleX</span> <span class="o">=</span> <span class="p">(</span><span class="n">desiredMagnification</span><span class="p">[</span><span class="s1">&#39;scale&#39;</span><span class="p">]</span> <span class="o">/</span>
                      <span class="n">desiredMagnification</span><span class="p">[</span><span class="s1">&#39;mm_x&#39;</span><span class="p">])</span>
            <span class="n">scaleY</span> <span class="o">=</span> <span class="p">(</span><span class="n">desiredMagnification</span><span class="p">[</span><span class="s1">&#39;scale&#39;</span><span class="p">]</span> <span class="o">/</span>
                      <span class="n">desiredMagnification</span><span class="p">[</span><span class="s1">&#39;mm_y&#39;</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">units</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;base_pixels&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid units </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">units</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">scaleX</span><span class="p">,</span> <span class="n">scaleY</span>

    <span class="k">def</span> <span class="nf">_getRegionBounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">top</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="n">bottom</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="n">desiredMagnification</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cropToImage</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                         <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a set of arguments that can include left, right, top, bottom,</span>
<span class="sd">        width, height, and units, generate actual pixel values for left, top,</span>
<span class="sd">        right, and bottom.  If left, top, right, or bottom are negative they</span>
<span class="sd">        are interpreted as an offset from the right or bottom edge of the</span>
<span class="sd">        image.</span>

<span class="sd">        :param metadata: the metadata associated with this source.</span>
<span class="sd">        :param left: the left edge (inclusive) of the region to process.</span>
<span class="sd">        :param top: the top edge (inclusive) of the region to process.</span>
<span class="sd">        :param right: the right edge (exclusive) of the region to process.</span>
<span class="sd">        :param bottom: the bottom edge (exclusive) of the region to process.</span>
<span class="sd">        :param width: the width of the region to process.  Ignored if both</span>
<span class="sd">            left and right are specified.</span>
<span class="sd">        :param height: the height of the region to process.  Ignores if both</span>
<span class="sd">            top and bottom are specified.</span>
<span class="sd">        :param units: either &#39;base_pixels&#39; (default), &#39;pixels&#39;, &#39;mm&#39;, or</span>
<span class="sd">            &#39;fraction&#39;.  base_pixels are in maximum resolution pixels.</span>
<span class="sd">            pixels is in the specified magnification pixels.  mm is in the</span>
<span class="sd">            specified magnification scale.  fraction is a scale of 0 to 1.</span>
<span class="sd">            pixels and mm are only available if the magnification and mm</span>
<span class="sd">            per pixel are defined for the image.</span>
<span class="sd">        :param desiredMagnification: the output from getMagnificationForLevel</span>
<span class="sd">            for the desired magnification used to convert mag_pixels and mm.</span>
<span class="sd">        :param cropToImage: if True, don&#39;t return region coordinates outside of</span>
<span class="sd">            the image.</span>
<span class="sd">        :param kwargs: optional parameters.  These are passed to</span>
<span class="sd">            _scaleFromUnits and may include unitsWH.</span>
<span class="sd">        :returns: left, top, right, bottom bounds in pixels.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">units</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">TileInputUnits</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid units </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">units</span><span class="p">)</span>
        <span class="c1"># Convert units to max-resolution pixels</span>
        <span class="n">units</span> <span class="o">=</span> <span class="n">TileInputUnits</span><span class="p">[</span><span class="n">units</span><span class="p">]</span>
        <span class="n">scaleX</span><span class="p">,</span> <span class="n">scaleY</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scaleFromUnits</span><span class="p">(</span><span class="n">metadata</span><span class="p">,</span> <span class="n">units</span><span class="p">,</span> <span class="n">desiredMagnification</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;unitsWH&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;unitsWH&#39;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">TileInputUnits</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid units </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;unitsWH&#39;</span><span class="p">])</span>
            <span class="n">scaleW</span><span class="p">,</span> <span class="n">scaleH</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scaleFromUnits</span><span class="p">(</span>
                <span class="n">metadata</span><span class="p">,</span> <span class="n">TileInputUnits</span><span class="p">[</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;unitsWH&#39;</span><span class="p">]],</span> <span class="n">desiredMagnification</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="c1"># if unitsWH is specified, prefer width and height to right and</span>
            <span class="c1"># bottom</span>
            <span class="k">if</span> <span class="n">left</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">right</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">width</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">right</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">top</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">bottom</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">height</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">bottom</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">scaleW</span><span class="p">,</span> <span class="n">scaleH</span> <span class="o">=</span> <span class="n">scaleX</span><span class="p">,</span> <span class="n">scaleY</span>
        <span class="n">region</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;left&#39;</span><span class="p">:</span> <span class="n">left</span><span class="p">,</span> <span class="s1">&#39;top&#39;</span><span class="p">:</span> <span class="n">top</span><span class="p">,</span> <span class="s1">&#39;right&#39;</span><span class="p">:</span> <span class="n">right</span><span class="p">,</span>
                  <span class="s1">&#39;bottom&#39;</span><span class="p">:</span> <span class="n">bottom</span><span class="p">,</span> <span class="s1">&#39;width&#39;</span><span class="p">:</span> <span class="n">width</span><span class="p">,</span> <span class="s1">&#39;height&#39;</span><span class="p">:</span> <span class="n">height</span><span class="p">}</span>
        <span class="n">region</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">region</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">region</span> <span class="k">if</span> <span class="n">region</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">scale</span> <span class="ow">in</span> <span class="p">(</span>
                <span class="p">(</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="n">scaleX</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;right&#39;</span><span class="p">,</span> <span class="n">scaleX</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;width&#39;</span><span class="p">,</span> <span class="n">scaleW</span><span class="p">),</span>
                <span class="p">(</span><span class="s1">&#39;top&#39;</span><span class="p">,</span> <span class="n">scaleY</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;bottom&#39;</span><span class="p">,</span> <span class="n">scaleY</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;height&#39;</span><span class="p">,</span> <span class="n">scaleH</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">region</span> <span class="ow">and</span> <span class="n">scale</span> <span class="ow">and</span> <span class="n">scale</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">region</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">region</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">*</span> <span class="n">scale</span>
        <span class="c1"># convert negative references to right or bottom offsets</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="s1">&#39;right&#39;</span><span class="p">,</span> <span class="s1">&#39;top&#39;</span><span class="p">,</span> <span class="s1">&#39;bottom&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">region</span> <span class="ow">and</span> <span class="n">region</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">region</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">+=</span> <span class="n">metadata</span><span class="p">[</span>
                    <span class="s1">&#39;sizeX&#39;</span> <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="s1">&#39;right&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="s1">&#39;sizeY&#39;</span><span class="p">]</span>
        <span class="c1"># Calculate the region we need to fetch</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">region</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
            <span class="s1">&#39;left&#39;</span><span class="p">,</span>
            <span class="p">(</span><span class="n">region</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;right&#39;</span><span class="p">)</span> <span class="o">-</span> <span class="n">region</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;width&#39;</span><span class="p">))</span>
            <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;right&#39;</span> <span class="ow">in</span> <span class="n">region</span> <span class="ow">and</span> <span class="s1">&#39;width&#39;</span> <span class="ow">in</span> <span class="n">region</span><span class="p">)</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">region</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
            <span class="s1">&#39;right&#39;</span><span class="p">,</span>
            <span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">region</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;width&#39;</span><span class="p">))</span>
            <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;width&#39;</span> <span class="ow">in</span> <span class="n">region</span><span class="p">)</span> <span class="k">else</span> <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;sizeX&#39;</span><span class="p">])</span>
        <span class="n">top</span> <span class="o">=</span> <span class="n">region</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
            <span class="s1">&#39;top&#39;</span><span class="p">,</span> <span class="n">region</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;bottom&#39;</span><span class="p">)</span> <span class="o">-</span> <span class="n">region</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;height&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="s1">&#39;bottom&#39;</span> <span class="ow">in</span> <span class="n">region</span> <span class="ow">and</span> <span class="s1">&#39;height&#39;</span> <span class="ow">in</span> <span class="n">region</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">bottom</span> <span class="o">=</span> <span class="n">region</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
            <span class="s1">&#39;bottom&#39;</span><span class="p">,</span> <span class="n">top</span> <span class="o">+</span> <span class="n">region</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;height&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="s1">&#39;height&#39;</span> <span class="ow">in</span> <span class="n">region</span> <span class="k">else</span> <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;sizeY&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">cropToImage</span><span class="p">:</span>
            <span class="c1"># Crop the bounds to integer pixels within the actual source data</span>
            <span class="n">left</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;sizeX&#39;</span><span class="p">],</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">left</span><span class="p">))))</span>
            <span class="n">right</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;sizeX&#39;</span><span class="p">],</span> <span class="nb">max</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">right</span><span class="p">))))</span>
            <span class="n">top</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;sizeY&#39;</span><span class="p">],</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">top</span><span class="p">))))</span>
            <span class="n">bottom</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;sizeY&#39;</span><span class="p">],</span> <span class="nb">max</span><span class="p">(</span><span class="n">top</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">bottom</span><span class="p">))))</span>

        <span class="k">return</span> <span class="n">left</span><span class="p">,</span> <span class="n">top</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">bottom</span>

    <span class="k">def</span> <span class="nf">_tileIteratorInfo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get information necessary to construct a tile iterator.</span>
<span class="sd">          If one of width or height is specified, the other is determined by</span>
<span class="sd">        preserving aspect ratio.  If both are specified, the result may not be</span>
<span class="sd">        that size, as aspect ratio is always preserved.  If neither are</span>
<span class="sd">        specified, magnification, mm_x, and/or mm_y are used to determine the</span>
<span class="sd">        size.  If none of those are specified, the original maximum resolution</span>
<span class="sd">        is returned.</span>

<span class="sd">        :param format: a tuple of allowed formats.  Formats are members of</span>
<span class="sd">            TILE_FORMAT_*.  This will avoid converting images if they are</span>
<span class="sd">            in the desired output encoding (regardless of subparameters).</span>
<span class="sd">            Otherwise, TILE_FORMAT_NUMPY is returned.</span>
<span class="sd">        :param region: a dictionary of optional values which specify the part</span>
<span class="sd">            of the image to process.</span>

<span class="sd">            :left: the left edge (inclusive) of the region to process.</span>
<span class="sd">            :top: the top edge (inclusive) of the region to process.</span>
<span class="sd">            :right: the right edge (exclusive) of the region to process.</span>
<span class="sd">            :bottom: the bottom edge (exclusive) of the region to process.</span>
<span class="sd">            :width: the width of the region to process.</span>
<span class="sd">            :height: the height of the region to process.</span>
<span class="sd">            :units: either &#39;base_pixels&#39; (default), &#39;pixels&#39;, &#39;mm&#39;, or</span>
<span class="sd">                &#39;fraction&#39;.  base_pixels are in maximum resolution pixels.</span>
<span class="sd">                pixels is in the specified magnification pixels.  mm is in the</span>
<span class="sd">                specified magnification scale.  fraction is a scale of 0 to 1.</span>
<span class="sd">                pixels and mm are only available if the magnification and mm</span>
<span class="sd">                per pixel are defined for the image.</span>
<span class="sd">            :unitsWH: if not specified, this is the same as `units`.</span>
<span class="sd">                Otherwise, these units will be used for the width and height if</span>
<span class="sd">                specified.</span>

<span class="sd">        :param output: a dictionary of optional values which specify the size</span>
<span class="sd">                of the output.</span>

<span class="sd">            :maxWidth: maximum width in pixels.</span>
<span class="sd">            :maxHeight: maximum height in pixels.</span>

<span class="sd">        :param scale: a dictionary of optional values which specify the scale</span>
<span class="sd">            of the region and / or output.  This applies to region if</span>
<span class="sd">            pixels or mm are used for units.  It applies to output if</span>
<span class="sd">            neither output maxWidth nor maxHeight is specified.</span>

<span class="sd">            :magnification: the magnification ratio.</span>
<span class="sd">            :mm_x: the horizontal size of a pixel in millimeters.</span>
<span class="sd">            :mm_y: the vertical size of a pixel in millimeters.</span>
<span class="sd">            :exact: if True, only a level that matches exactly will be</span>
<span class="sd">                returned.  This is only applied if magnification, mm_x, or mm_y</span>
<span class="sd">                is used.</span>

<span class="sd">        :param tile_position: if present, either a number to only yield the</span>
<span class="sd">            (tile_position)th tile [0 to (xmax - min) * (ymax - ymin)) that the</span>
<span class="sd">            iterator would yield, or a dictionary of {region_x, region_y} to</span>
<span class="sd">            yield that tile, where 0, 0 is the first tile yielded, and</span>
<span class="sd">            xmax - xmin - 1, ymax - ymin - 1 is the last tile yielded, or a</span>
<span class="sd">            dictionary of {level_x, level_y} to yield that specific tile if it</span>
<span class="sd">            is in the region.</span>
<span class="sd">        :param tile_size: if present, retile the output to the specified tile</span>
<span class="sd">            size.  If only width or only height is specified, the resultant</span>
<span class="sd">            tiles will be square.  This is a dictionary containing at least</span>
<span class="sd">            one of:</span>

<span class="sd">            :width: the desired tile width.</span>
<span class="sd">            :height: the desired tile height.</span>

<span class="sd">        :param tile_overlap: if present, retile the output adding a symmetric</span>
<span class="sd">            overlap to the tiles.  If either x or y is not specified, it</span>
<span class="sd">            defaults to zero.  The overlap does not change the tile size,</span>
<span class="sd">            only the stride of the tiles.  This is a dictionary containing:</span>

<span class="sd">            :x: the horizontal overlap in pixels.</span>
<span class="sd">            :y: the vertical overlap in pixels.</span>
<span class="sd">            :edges: if True, then the edge tiles will exclude the overlap</span>
<span class="sd">                distance.  If unset or False, the edge tiles are full size.</span>

<span class="sd">        :param kwargs: optional arguments.  Some options are encoding,</span>
<span class="sd">            jpegQuality, jpegSubsampling, tiffCompression, frame.</span>
<span class="sd">        :returns: a dictionary of information needed for the tile iterator.</span>
<span class="sd">            This is None if no tiles will be returned.  Otherwise, this</span>
<span class="sd">            contains:</span>

<span class="sd">            :region: a dictionary of the source region information:</span>

<span class="sd">                :width, height: the total output of the iterator in pixels.</span>
<span class="sd">                    This may be larger than the requested resolution (given by</span>
<span class="sd">                    output width and output height) if there isn&#39;t an exact</span>
<span class="sd">                    match between the requested resolution and available native</span>
<span class="sd">                    tiles.</span>
<span class="sd">                :left, top, right, bottom: the coordinates within the image of</span>
<span class="sd">                    the region returned in the level pixel space.</span>

<span class="sd">            :xmin, ymin, xmax, ymax: the tiles that will be included during the</span>
<span class="sd">                iteration: [xmin, xmax) and [ymin, ymax).</span>
<span class="sd">            :mode: either &#39;RGB&#39; or &#39;RGBA&#39;.  This determines the color space</span>
<span class="sd">                used for tiles.</span>
<span class="sd">            :level: the tile level used for iteration.</span>
<span class="sd">            :metadata: tile source metadata (from getMetadata)</span>
<span class="sd">            :output: a dictionary of the output resolution information.</span>

<span class="sd">                :width, height: the requested output resolution in pixels.  If</span>
<span class="sd">                    this is different that region width and region height, then</span>
<span class="sd">                    the original request was asking for a different scale than</span>
<span class="sd">                    is being delivered.</span>

<span class="sd">            :frame: the frame value for the base image.</span>
<span class="sd">            :format: a tuple of allowed output formats.</span>
<span class="sd">            :encoding: if the output format is TILE_FORMAT_IMAGE, the desired</span>
<span class="sd">                encoding.</span>
<span class="sd">            :requestedScale: the scale needed to convert from the region width</span>
<span class="sd">                and height to the output width and height.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">maxWidth</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;output&#39;</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;maxWidth&#39;</span><span class="p">)</span>
        <span class="n">maxHeight</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;output&#39;</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;maxHeight&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">maxWidth</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
                <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">maxWidth</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="n">maxWidth</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="ow">or</span>
                <span class="p">(</span><span class="n">maxHeight</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
                 <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">maxHeight</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="n">maxHeight</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;Invalid output width or height.  Minimum value is 0.&#39;</span><span class="p">)</span>

        <span class="n">magLevel</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">mag</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">maxWidth</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">maxHeight</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># If neither width nor height as specified, see if magnification,</span>
            <span class="c1"># mm_x, or mm_y are requested.</span>
            <span class="n">magArgs</span> <span class="o">=</span> <span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;scale&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">{})</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">magArgs</span><span class="p">[</span><span class="s1">&#39;rounding&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">magLevel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getLevelForMagnification</span><span class="p">(</span><span class="o">**</span><span class="n">magArgs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">magLevel</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;scale&#39;</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;exact&#39;</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="n">mag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getMagnificationForLevel</span><span class="p">(</span><span class="n">magLevel</span><span class="p">)</span>
        <span class="n">metadata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getMetadata</span><span class="p">()</span>
        <span class="n">left</span><span class="p">,</span> <span class="n">top</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">bottom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getRegionBounds</span><span class="p">(</span>
            <span class="n">metadata</span><span class="p">,</span> <span class="n">desiredMagnification</span><span class="o">=</span><span class="n">mag</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;region&#39;</span><span class="p">,</span> <span class="p">{}))</span>
        <span class="n">regionWidth</span> <span class="o">=</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span>
        <span class="n">regionHeight</span> <span class="o">=</span> <span class="n">bottom</span> <span class="o">-</span> <span class="n">top</span>
        <span class="n">requestedScale</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">maxWidth</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">maxHeight</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">mag</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;scale&#39;</span><span class="p">)</span> <span class="ow">in</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
                <span class="n">maxWidth</span><span class="p">,</span> <span class="n">maxHeight</span> <span class="o">=</span> <span class="n">regionWidth</span><span class="p">,</span> <span class="n">regionHeight</span>
                <span class="n">requestedScale</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">maxWidth</span> <span class="o">=</span> <span class="n">regionWidth</span> <span class="o">/</span> <span class="n">mag</span><span class="p">[</span><span class="s1">&#39;scale&#39;</span><span class="p">]</span>
                <span class="n">maxHeight</span> <span class="o">=</span> <span class="n">regionHeight</span> <span class="o">/</span> <span class="n">mag</span><span class="p">[</span><span class="s1">&#39;scale&#39;</span><span class="p">]</span>
                <span class="n">requestedScale</span> <span class="o">=</span> <span class="n">mag</span><span class="p">[</span><span class="s1">&#39;scale&#39;</span><span class="p">]</span>
        <span class="n">outWidth</span><span class="p">,</span> <span class="n">outHeight</span><span class="p">,</span> <span class="n">calcScale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculateWidthHeight</span><span class="p">(</span>
            <span class="n">maxWidth</span><span class="p">,</span> <span class="n">maxHeight</span><span class="p">,</span> <span class="n">regionWidth</span><span class="p">,</span> <span class="n">regionHeight</span><span class="p">)</span>
        <span class="n">requestedScale</span> <span class="o">=</span> <span class="n">calcScale</span> <span class="k">if</span> <span class="n">requestedScale</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">requestedScale</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">regionWidth</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">regionHeight</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">outWidth</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span>
                <span class="n">outHeight</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">preferredLevel</span> <span class="o">=</span> <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;levels&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="c1"># If we are scaling the result, pick the tile level that is at least</span>
        <span class="c1"># the resolution we need and is preferred by the tile source.</span>
        <span class="k">if</span> <span class="n">outWidth</span> <span class="o">!=</span> <span class="n">regionWidth</span> <span class="ow">or</span> <span class="n">outHeight</span> <span class="o">!=</span> <span class="n">regionHeight</span><span class="p">:</span>
            <span class="n">newLevel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getPreferredLevel</span><span class="p">(</span><span class="n">preferredLevel</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span>
                <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">outWidth</span><span class="p">)</span> <span class="o">/</span> <span class="n">regionWidth</span><span class="p">,</span>
                                             <span class="nb">float</span><span class="p">(</span><span class="n">outHeight</span><span class="p">)</span> <span class="o">/</span> <span class="n">regionHeight</span><span class="p">))</span> <span class="o">/</span>
                                <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="mi">4</span><span class="p">))))</span>
            <span class="k">if</span> <span class="n">newLevel</span> <span class="o">&lt;</span> <span class="n">preferredLevel</span><span class="p">:</span>
                <span class="c1"># scale the bounds to the level we will use</span>
                <span class="n">factor</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="n">preferredLevel</span> <span class="o">-</span> <span class="n">newLevel</span><span class="p">)</span>
                <span class="n">left</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">left</span> <span class="o">/</span> <span class="n">factor</span><span class="p">)</span>
                <span class="n">right</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">right</span> <span class="o">/</span> <span class="n">factor</span><span class="p">)</span>
                <span class="n">regionWidth</span> <span class="o">=</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span>
                <span class="n">top</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">top</span> <span class="o">/</span> <span class="n">factor</span><span class="p">)</span>
                <span class="n">bottom</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">bottom</span> <span class="o">/</span> <span class="n">factor</span><span class="p">)</span>
                <span class="n">regionHeight</span> <span class="o">=</span> <span class="n">bottom</span> <span class="o">-</span> <span class="n">top</span>
                <span class="n">preferredLevel</span> <span class="o">=</span> <span class="n">newLevel</span>
                <span class="n">requestedScale</span> <span class="o">/=</span> <span class="n">factor</span>
        <span class="c1"># If an exact magnification was requested and this tile source doesn&#39;t</span>
        <span class="c1"># have tiles at the appropriate level, indicate that we won&#39;t return</span>
        <span class="c1"># anything.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">magLevel</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">magLevel</span> <span class="o">!=</span> <span class="n">preferredLevel</span> <span class="ow">and</span>
                <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;scale&#39;</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;exact&#39;</span><span class="p">)):</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">tile_size</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;width&#39;</span><span class="p">:</span> <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;tileWidth&#39;</span><span class="p">],</span>
            <span class="s1">&#39;height&#39;</span><span class="p">:</span> <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;tileHeight&#39;</span><span class="p">],</span>
        <span class="p">}</span>
        <span class="n">tile_overlap</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;tile_overlap&#39;</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="mi">0</span><span class="p">),</span>
            <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;tile_overlap&#39;</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="mi">0</span><span class="p">),</span>
            <span class="s1">&#39;edges&#39;</span><span class="p">:</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;tile_overlap&#39;</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;edges&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span>
            <span class="s1">&#39;offset_x&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s1">&#39;offset_y&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">tile_overlap</span><span class="p">[</span><span class="s1">&#39;edges&#39;</span><span class="p">]:</span>
            <span class="c1"># offset by half the overlap</span>
            <span class="n">tile_overlap</span><span class="p">[</span><span class="s1">&#39;offset_x&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tile_overlap</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="n">tile_overlap</span><span class="p">[</span><span class="s1">&#39;offset_y&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tile_overlap</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="s1">&#39;tile_size&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">tile_size</span><span class="p">[</span><span class="s1">&#39;width&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;tile_size&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                <span class="s1">&#39;width&#39;</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;tile_size&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;height&#39;</span><span class="p">,</span> <span class="n">tile_size</span><span class="p">[</span><span class="s1">&#39;width&#39;</span><span class="p">])))</span>
            <span class="n">tile_size</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;tile_size&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                <span class="s1">&#39;height&#39;</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;tile_size&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;width&#39;</span><span class="p">,</span> <span class="n">tile_size</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">])))</span>
        <span class="c1"># Tile size includes the overlap</span>
        <span class="n">tile_size</span><span class="p">[</span><span class="s1">&#39;width&#39;</span><span class="p">]</span> <span class="o">-=</span> <span class="n">tile_overlap</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span>
        <span class="n">tile_size</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">]</span> <span class="o">-=</span> <span class="n">tile_overlap</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">tile_size</span><span class="p">[</span><span class="s1">&#39;width&#39;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">tile_size</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid tile_size or tile_overlap.&#39;</span><span class="p">)</span>

        <span class="n">resample</span> <span class="o">=</span> <span class="p">(</span>
            <span class="kc">False</span> <span class="k">if</span> <span class="nb">round</span><span class="p">(</span><span class="n">requestedScale</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mf">1.0</span> <span class="ow">or</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;resample&#39;</span><span class="p">)</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> <span class="k">else</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;resample&#39;</span><span class="p">))</span>
        <span class="c1"># If we need to resample to make tiles at a non-native resolution,</span>
        <span class="c1"># adjust the tile size and tile overlap parameters appropriately.</span>
        <span class="k">if</span> <span class="n">resample</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">tile_size</span><span class="p">[</span><span class="s1">&#39;width&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">tile_size</span><span class="p">[</span><span class="s1">&#39;width&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">requestedScale</span><span class="p">)))</span>
            <span class="n">tile_size</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">tile_size</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">requestedScale</span><span class="p">)))</span>
            <span class="n">tile_overlap</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">tile_overlap</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">requestedScale</span><span class="p">))</span>
            <span class="n">tile_overlap</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">tile_overlap</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">requestedScale</span><span class="p">))</span>

        <span class="c1"># If the overlapped tiles don&#39;t run over the edge, then the functional</span>
        <span class="c1"># size of the region is reduced by the overlap.  This factor is stored</span>
        <span class="c1"># in the overlap offset_*.</span>
        <span class="n">xmin</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">left</span> <span class="o">/</span> <span class="n">tile_size</span><span class="p">[</span><span class="s1">&#39;width&#39;</span><span class="p">])</span>
        <span class="n">xmax</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="nb">float</span><span class="p">(</span><span class="n">right</span><span class="p">)</span> <span class="o">-</span> <span class="n">tile_overlap</span><span class="p">[</span><span class="s1">&#39;offset_x&#39;</span><span class="p">])</span> <span class="o">/</span>
                             <span class="n">tile_size</span><span class="p">[</span><span class="s1">&#39;width&#39;</span><span class="p">]))</span>
        <span class="n">ymin</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">top</span> <span class="o">/</span> <span class="n">tile_size</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">])</span>
        <span class="n">ymax</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="nb">float</span><span class="p">(</span><span class="n">bottom</span><span class="p">)</span> <span class="o">-</span> <span class="n">tile_overlap</span><span class="p">[</span><span class="s1">&#39;offset_y&#39;</span><span class="p">])</span> <span class="o">/</span>
                             <span class="n">tile_size</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">]))</span>
        <span class="n">tile_overlap</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;xmin&#39;</span><span class="p">:</span> <span class="n">xmin</span><span class="p">,</span> <span class="s1">&#39;xmax&#39;</span><span class="p">:</span> <span class="n">xmax</span><span class="p">,</span>
                             <span class="s1">&#39;ymin&#39;</span><span class="p">:</span> <span class="n">ymin</span><span class="p">,</span> <span class="s1">&#39;ymax&#39;</span><span class="p">:</span> <span class="n">ymax</span><span class="p">})</span>

        <span class="c1"># Use RGB for JPEG, RGBA for PNG</span>
        <span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;RGBA&#39;</span> <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;encoding&#39;</span><span class="p">)</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;PNG&#39;</span><span class="p">,</span> <span class="s1">&#39;TIFF&#39;</span><span class="p">,</span> <span class="s1">&#39;TILED&#39;</span><span class="p">}</span> <span class="k">else</span> <span class="s1">&#39;RGB&#39;</span>

        <span class="n">info</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;region&#39;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s1">&#39;top&#39;</span><span class="p">:</span> <span class="n">top</span><span class="p">,</span>
                <span class="s1">&#39;left&#39;</span><span class="p">:</span> <span class="n">left</span><span class="p">,</span>
                <span class="s1">&#39;bottom&#39;</span><span class="p">:</span> <span class="n">bottom</span><span class="p">,</span>
                <span class="s1">&#39;right&#39;</span><span class="p">:</span> <span class="n">right</span><span class="p">,</span>
                <span class="s1">&#39;width&#39;</span><span class="p">:</span> <span class="n">regionWidth</span><span class="p">,</span>
                <span class="s1">&#39;height&#39;</span><span class="p">:</span> <span class="n">regionHeight</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="s1">&#39;xmin&#39;</span><span class="p">:</span> <span class="n">xmin</span><span class="p">,</span>
            <span class="s1">&#39;ymin&#39;</span><span class="p">:</span> <span class="n">ymin</span><span class="p">,</span>
            <span class="s1">&#39;xmax&#39;</span><span class="p">:</span> <span class="n">xmax</span><span class="p">,</span>
            <span class="s1">&#39;ymax&#39;</span><span class="p">:</span> <span class="n">ymax</span><span class="p">,</span>
            <span class="s1">&#39;mode&#39;</span><span class="p">:</span> <span class="n">mode</span><span class="p">,</span>
            <span class="s1">&#39;level&#39;</span><span class="p">:</span> <span class="n">preferredLevel</span><span class="p">,</span>
            <span class="s1">&#39;metadata&#39;</span><span class="p">:</span> <span class="n">metadata</span><span class="p">,</span>
            <span class="s1">&#39;output&#39;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s1">&#39;width&#39;</span><span class="p">:</span> <span class="n">outWidth</span><span class="p">,</span>
                <span class="s1">&#39;height&#39;</span><span class="p">:</span> <span class="n">outHeight</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="s1">&#39;frame&#39;</span><span class="p">:</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;frame&#39;</span><span class="p">),</span>
            <span class="s1">&#39;format&#39;</span><span class="p">:</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;format&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">TILE_FORMAT_NUMPY</span><span class="p">,</span> <span class="p">)),</span>
            <span class="s1">&#39;encoding&#39;</span><span class="p">:</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;encoding&#39;</span><span class="p">),</span>
            <span class="s1">&#39;requestedScale&#39;</span><span class="p">:</span> <span class="n">requestedScale</span><span class="p">,</span>
            <span class="s1">&#39;resample&#39;</span><span class="p">:</span> <span class="n">resample</span><span class="p">,</span>
            <span class="s1">&#39;tile_overlap&#39;</span><span class="p">:</span> <span class="n">tile_overlap</span><span class="p">,</span>
            <span class="s1">&#39;tile_position&#39;</span><span class="p">:</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;tile_position&#39;</span><span class="p">),</span>
            <span class="s1">&#39;tile_size&#39;</span><span class="p">:</span> <span class="n">tile_size</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">info</span>

    <span class="k">def</span> <span class="nf">_tileIterator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iterInfo</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given tile iterator information, iterate through the tiles.</span>
<span class="sd">        Each tile is returned as part of a dictionary that includes</span>

<span class="sd">            :x, y: (left, top) coordinate in current magnification pixels</span>
<span class="sd">            :width, height: size of current tile in current magnification</span>
<span class="sd">                pixels</span>
<span class="sd">            :tile: cropped tile image</span>
<span class="sd">            :format: format of the tile.  One of TILE_FORMAT_NUMPY,</span>
<span class="sd">                TILE_FORMAT_PIL, or TILE_FORMAT_IMAGE.  TILE_FORMAT_IMAGE is</span>
<span class="sd">                only returned if it was explicitly allowed and the tile is</span>
<span class="sd">                already in the correct image encoding.</span>
<span class="sd">            :level: level of the current tile</span>
<span class="sd">            :level_x, level_y: the tile reference number within the level.</span>
<span class="sd">                Tiles are numbered (0, 0), (1, 0), (2, 0), etc.  The 0th tile</span>
<span class="sd">                yielded may not be (0, 0) if a region is specified.</span>
<span class="sd">            :tile_position: a dictionary of the tile position within the</span>
<span class="sd">                iterator, containing:</span>

<span class="sd">                :level_x, level_y: the tile reference number within the level.</span>
<span class="sd">                :region_x, region_y: 0, 0 is the first tile in the full</span>
<span class="sd">                    iteration (when not restricting the iteration to a single</span>
<span class="sd">                    tile).</span>
<span class="sd">                :position: a 0-based value for the tile within the full</span>
<span class="sd">                    iteration.</span>

<span class="sd">            :iterator_range: a dictionary of the output range of the iterator:</span>

<span class="sd">                :level_x_min, level_x_max: the tiles that are be included</span>
<span class="sd">                    during the full iteration: [layer_x_min, layer_x_max).</span>
<span class="sd">                :level_y_min, level_y_max: the tiles that are be included</span>
<span class="sd">                    during the full iteration: [layer_y_min, layer_y_max).</span>
<span class="sd">                :region_x_max, region_y_max: the number of tiles included during</span>
<span class="sd">                    the full iteration.   This is layer_x_max - layer_x_min,</span>
<span class="sd">                    layer_y_max - layer_y_min.</span>
<span class="sd">                :position: the total number of tiles included in the full</span>
<span class="sd">                    iteration.  This is region_x_max * region_y_max.</span>

<span class="sd">            :magnification: magnification of the current tile</span>
<span class="sd">            :mm_x, mm_y: size of the current tile pixel in millimeters.</span>
<span class="sd">            :gx, gy: (left, top) coordinates in maximum-resolution pixels</span>
<span class="sd">            :gwidth, gheight: size of of the current tile in maximum-resolution</span>
<span class="sd">                pixels.</span>
<span class="sd">            :tile_overlap: the amount of overlap with neighboring tiles (left,</span>
<span class="sd">                top, right, and bottom).  Overlap never extends outside of the</span>
<span class="sd">                requested region.</span>

<span class="sd">        If a region that includes partial tiles is requested, those tiles are</span>
<span class="sd">        cropped appropriately.  Most images will have tiles that get cropped</span>
<span class="sd">        along the right and bottom edges in any case.</span>

<span class="sd">        :param iterInfo: tile iterator information.  See _tileIteratorInfo.</span>
<span class="sd">        :yields: an iterator that returns a dictionary as listed above.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">regionWidth</span> <span class="o">=</span> <span class="n">iterInfo</span><span class="p">[</span><span class="s1">&#39;region&#39;</span><span class="p">][</span><span class="s1">&#39;width&#39;</span><span class="p">]</span>
        <span class="n">regionHeight</span> <span class="o">=</span> <span class="n">iterInfo</span><span class="p">[</span><span class="s1">&#39;region&#39;</span><span class="p">][</span><span class="s1">&#39;height&#39;</span><span class="p">]</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">iterInfo</span><span class="p">[</span><span class="s1">&#39;region&#39;</span><span class="p">][</span><span class="s1">&#39;left&#39;</span><span class="p">]</span>
        <span class="n">top</span> <span class="o">=</span> <span class="n">iterInfo</span><span class="p">[</span><span class="s1">&#39;region&#39;</span><span class="p">][</span><span class="s1">&#39;top&#39;</span><span class="p">]</span>
        <span class="n">xmin</span> <span class="o">=</span> <span class="n">iterInfo</span><span class="p">[</span><span class="s1">&#39;xmin&#39;</span><span class="p">]</span>
        <span class="n">ymin</span> <span class="o">=</span> <span class="n">iterInfo</span><span class="p">[</span><span class="s1">&#39;ymin&#39;</span><span class="p">]</span>
        <span class="n">xmax</span> <span class="o">=</span> <span class="n">iterInfo</span><span class="p">[</span><span class="s1">&#39;xmax&#39;</span><span class="p">]</span>
        <span class="n">ymax</span> <span class="o">=</span> <span class="n">iterInfo</span><span class="p">[</span><span class="s1">&#39;ymax&#39;</span><span class="p">]</span>
        <span class="n">level</span> <span class="o">=</span> <span class="n">iterInfo</span><span class="p">[</span><span class="s1">&#39;level&#39;</span><span class="p">]</span>
        <span class="n">metadata</span> <span class="o">=</span> <span class="n">iterInfo</span><span class="p">[</span><span class="s1">&#39;metadata&#39;</span><span class="p">]</span>
        <span class="n">tileSize</span> <span class="o">=</span> <span class="n">iterInfo</span><span class="p">[</span><span class="s1">&#39;tile_size&#39;</span><span class="p">]</span>
        <span class="n">tileOverlap</span> <span class="o">=</span> <span class="n">iterInfo</span><span class="p">[</span><span class="s1">&#39;tile_overlap&#39;</span><span class="p">]</span>
        <span class="nb">format</span> <span class="o">=</span> <span class="n">iterInfo</span><span class="p">[</span><span class="s1">&#39;format&#39;</span><span class="p">]</span>
        <span class="n">encoding</span> <span class="o">=</span> <span class="n">iterInfo</span><span class="p">[</span><span class="s1">&#39;encoding&#39;</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s1">&#39;Fetching region of an image with a source size of </span><span class="si">%d</span><span class="s1"> x </span><span class="si">%d</span><span class="s1">; &#39;</span>
            <span class="s1">&#39;getting </span><span class="si">%d</span><span class="s1"> tiles&#39;</span><span class="p">,</span>
            <span class="n">regionWidth</span><span class="p">,</span> <span class="n">regionHeight</span><span class="p">,</span> <span class="p">(</span><span class="n">xmax</span> <span class="o">-</span> <span class="n">xmin</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">ymax</span> <span class="o">-</span> <span class="n">ymin</span><span class="p">))</span>

        <span class="c1"># If tile is specified, return at most one tile</span>
        <span class="k">if</span> <span class="n">iterInfo</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;tile_position&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tilePos</span> <span class="o">=</span> <span class="n">iterInfo</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;tile_position&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tilePos</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">tilePos</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;position&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">tilePos</span> <span class="o">=</span> <span class="n">tilePos</span><span class="p">[</span><span class="s1">&#39;position&#39;</span><span class="p">]</span>
                <span class="k">elif</span> <span class="s1">&#39;region_x&#39;</span> <span class="ow">in</span> <span class="n">tilePos</span> <span class="ow">and</span> <span class="s1">&#39;region_y&#39;</span> <span class="ow">in</span> <span class="n">tilePos</span><span class="p">:</span>
                    <span class="n">tilePos</span> <span class="o">=</span> <span class="p">(</span><span class="n">tilePos</span><span class="p">[</span><span class="s1">&#39;region_x&#39;</span><span class="p">]</span> <span class="o">+</span>
                               <span class="n">tilePos</span><span class="p">[</span><span class="s1">&#39;region_y&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">xmax</span> <span class="o">-</span> <span class="n">xmin</span><span class="p">))</span>
                <span class="k">elif</span> <span class="s1">&#39;level_x&#39;</span> <span class="ow">in</span> <span class="n">tilePos</span> <span class="ow">and</span> <span class="s1">&#39;level_y&#39;</span> <span class="ow">in</span> <span class="n">tilePos</span><span class="p">:</span>
                    <span class="n">tilePos</span> <span class="o">=</span> <span class="p">((</span><span class="n">tilePos</span><span class="p">[</span><span class="s1">&#39;level_x&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">xmin</span><span class="p">)</span> <span class="o">+</span>
                               <span class="p">(</span><span class="n">tilePos</span><span class="p">[</span><span class="s1">&#39;level_y&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">ymin</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">xmax</span> <span class="o">-</span> <span class="n">xmin</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">tilePos</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">tilePos</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">ymax</span> <span class="o">-</span> <span class="n">ymin</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">xmax</span> <span class="o">-</span> <span class="n">xmin</span><span class="p">):</span>
                <span class="n">xmax</span> <span class="o">=</span> <span class="n">xmin</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ymin</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tilePos</span> <span class="o">/</span> <span class="p">(</span><span class="n">xmax</span> <span class="o">-</span> <span class="n">xmin</span><span class="p">))</span>
                <span class="n">ymax</span> <span class="o">=</span> <span class="n">ymin</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">xmin</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tilePos</span> <span class="o">%</span> <span class="p">(</span><span class="n">xmax</span> <span class="o">-</span> <span class="n">xmin</span><span class="p">))</span>
                <span class="n">xmax</span> <span class="o">=</span> <span class="n">xmin</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">mag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getMagnificationForLevel</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="n">mag</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;scale&#39;</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
        <span class="n">retile</span> <span class="o">=</span> <span class="p">(</span><span class="n">tileSize</span><span class="p">[</span><span class="s1">&#39;width&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;tileWidth&#39;</span><span class="p">]</span> <span class="ow">or</span>
                  <span class="n">tileSize</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;tileHeight&#39;</span><span class="p">]</span> <span class="ow">or</span>
                  <span class="n">tileOverlap</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span> <span class="ow">or</span> <span class="n">tileOverlap</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">):</span>
                <span class="n">crop</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">posX</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">tileSize</span><span class="p">[</span><span class="s1">&#39;width&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">tileOverlap</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span>
                           <span class="n">tileOverlap</span><span class="p">[</span><span class="s1">&#39;offset_x&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">left</span><span class="p">)</span>
                <span class="n">posY</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">y</span> <span class="o">*</span> <span class="n">tileSize</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">tileOverlap</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span>
                           <span class="n">tileOverlap</span><span class="p">[</span><span class="s1">&#39;offset_y&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">top</span><span class="p">)</span>
                <span class="n">tileWidth</span> <span class="o">=</span> <span class="n">tileSize</span><span class="p">[</span><span class="s1">&#39;width&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">tileOverlap</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span>
                <span class="n">tileHeight</span> <span class="o">=</span> <span class="n">tileSize</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">tileOverlap</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span>
                <span class="c1"># crop as needed</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">posX</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">posY</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">posX</span> <span class="o">+</span> <span class="n">tileWidth</span> <span class="o">&gt;</span> <span class="n">regionWidth</span> <span class="ow">or</span>
                        <span class="n">posY</span> <span class="o">+</span> <span class="n">tileHeight</span> <span class="o">&gt;</span> <span class="n">regionHeight</span><span class="p">):</span>
                    <span class="n">crop</span> <span class="o">=</span> <span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">posX</span><span class="p">),</span>
                            <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">posY</span><span class="p">),</span>
                            <span class="nb">int</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">tileWidth</span><span class="p">,</span> <span class="n">regionWidth</span> <span class="o">-</span> <span class="n">posX</span><span class="p">)),</span>
                            <span class="nb">int</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">tileHeight</span><span class="p">,</span> <span class="n">regionHeight</span> <span class="o">-</span> <span class="n">posY</span><span class="p">)))</span>
                    <span class="n">posX</span> <span class="o">+=</span> <span class="n">crop</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">posY</span> <span class="o">+=</span> <span class="n">crop</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">tileWidth</span> <span class="o">=</span> <span class="n">crop</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">crop</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">tileHeight</span> <span class="o">=</span> <span class="n">crop</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">crop</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">overlap</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s1">&#39;left&#39;</span><span class="p">:</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span> <span class="o">*</span> <span class="n">tileSize</span><span class="p">[</span><span class="s1">&#39;width&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">tileOverlap</span><span class="p">[</span><span class="s1">&#39;offset_x&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">left</span> <span class="o">-</span> <span class="n">posX</span><span class="p">),</span>
                    <span class="s1">&#39;top&#39;</span><span class="p">:</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">y</span> <span class="o">*</span> <span class="n">tileSize</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">tileOverlap</span><span class="p">[</span><span class="s1">&#39;offset_y&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">top</span> <span class="o">-</span> <span class="n">posY</span><span class="p">),</span>
                <span class="p">}</span>
                <span class="n">overlap</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">tileWidth</span> <span class="o">-</span> <span class="n">tileSize</span><span class="p">[</span><span class="s1">&#39;width&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">overlap</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">])</span>
                <span class="n">overlap</span><span class="p">[</span><span class="s1">&#39;bottom&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">tileHeight</span> <span class="o">-</span> <span class="n">tileSize</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">overlap</span><span class="p">[</span><span class="s1">&#39;top&#39;</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">tileOverlap</span><span class="p">[</span><span class="s1">&#39;offset_x&#39;</span><span class="p">]:</span>
                    <span class="n">overlap</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">tileOverlap</span><span class="p">[</span><span class="s1">&#39;xmin&#39;</span><span class="p">]</span> <span class="k">else</span> <span class="n">overlap</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">]</span>
                    <span class="n">overlap</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">tileOverlap</span><span class="p">[</span><span class="s1">&#39;xmax&#39;</span><span class="p">]</span> <span class="k">else</span> <span class="n">overlap</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">tileOverlap</span><span class="p">[</span><span class="s1">&#39;offset_y&#39;</span><span class="p">]:</span>
                    <span class="n">overlap</span><span class="p">[</span><span class="s1">&#39;top&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">y</span> <span class="o">==</span> <span class="n">tileOverlap</span><span class="p">[</span><span class="s1">&#39;ymin&#39;</span><span class="p">]</span> <span class="k">else</span> <span class="n">overlap</span><span class="p">[</span><span class="s1">&#39;top&#39;</span><span class="p">]</span>
                    <span class="n">overlap</span><span class="p">[</span><span class="s1">&#39;bottom&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">tileOverlap</span><span class="p">[</span><span class="s1">&#39;ymax&#39;</span><span class="p">]</span> <span class="k">else</span> <span class="n">overlap</span><span class="p">[</span><span class="s1">&#39;bottom&#39;</span><span class="p">]</span>
                <span class="n">tile</span> <span class="o">=</span> <span class="n">LazyTileDict</span><span class="p">({</span>
                    <span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span>
                    <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="n">y</span><span class="p">,</span>
                    <span class="s1">&#39;frame&#39;</span><span class="p">:</span> <span class="n">iterInfo</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;frame&#39;</span><span class="p">),</span>
                    <span class="s1">&#39;level&#39;</span><span class="p">:</span> <span class="n">level</span><span class="p">,</span>
                    <span class="s1">&#39;format&#39;</span><span class="p">:</span> <span class="nb">format</span><span class="p">,</span>
                    <span class="s1">&#39;encoding&#39;</span><span class="p">:</span> <span class="n">encoding</span><span class="p">,</span>
                    <span class="s1">&#39;crop&#39;</span><span class="p">:</span> <span class="n">crop</span><span class="p">,</span>
                    <span class="s1">&#39;requestedScale&#39;</span><span class="p">:</span> <span class="n">iterInfo</span><span class="p">[</span><span class="s1">&#39;requestedScale&#39;</span><span class="p">],</span>
                    <span class="s1">&#39;retile&#39;</span><span class="p">:</span> <span class="n">retile</span><span class="p">,</span>
                    <span class="s1">&#39;metadata&#39;</span><span class="p">:</span> <span class="n">metadata</span><span class="p">,</span>
                    <span class="s1">&#39;source&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="p">,</span>
                <span class="p">},</span> <span class="p">{</span>
                    <span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="n">posX</span> <span class="o">+</span> <span class="n">left</span><span class="p">,</span>
                    <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="n">posY</span> <span class="o">+</span> <span class="n">top</span><span class="p">,</span>
                    <span class="s1">&#39;width&#39;</span><span class="p">:</span> <span class="n">tileWidth</span><span class="p">,</span>
                    <span class="s1">&#39;height&#39;</span><span class="p">:</span> <span class="n">tileHeight</span><span class="p">,</span>
                    <span class="s1">&#39;level&#39;</span><span class="p">:</span> <span class="n">level</span><span class="p">,</span>
                    <span class="s1">&#39;level_x&#39;</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span>
                    <span class="s1">&#39;level_y&#39;</span><span class="p">:</span> <span class="n">y</span><span class="p">,</span>
                    <span class="s1">&#39;magnification&#39;</span><span class="p">:</span> <span class="n">mag</span><span class="p">[</span><span class="s1">&#39;magnification&#39;</span><span class="p">],</span>
                    <span class="s1">&#39;mm_x&#39;</span><span class="p">:</span> <span class="n">mag</span><span class="p">[</span><span class="s1">&#39;mm_x&#39;</span><span class="p">],</span>
                    <span class="s1">&#39;mm_y&#39;</span><span class="p">:</span> <span class="n">mag</span><span class="p">[</span><span class="s1">&#39;mm_y&#39;</span><span class="p">],</span>
                    <span class="s1">&#39;tile_position&#39;</span><span class="p">:</span> <span class="p">{</span>
                        <span class="s1">&#39;level_x&#39;</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span>
                        <span class="s1">&#39;level_y&#39;</span><span class="p">:</span> <span class="n">y</span><span class="p">,</span>
                        <span class="s1">&#39;region_x&#39;</span><span class="p">:</span> <span class="n">x</span> <span class="o">-</span> <span class="n">iterInfo</span><span class="p">[</span><span class="s1">&#39;xmin&#39;</span><span class="p">],</span>
                        <span class="s1">&#39;region_y&#39;</span><span class="p">:</span> <span class="n">y</span> <span class="o">-</span> <span class="n">iterInfo</span><span class="p">[</span><span class="s1">&#39;ymin&#39;</span><span class="p">],</span>
                        <span class="s1">&#39;position&#39;</span><span class="p">:</span> <span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">iterInfo</span><span class="p">[</span><span class="s1">&#39;xmin&#39;</span><span class="p">])</span> <span class="o">+</span>
                                     <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">iterInfo</span><span class="p">[</span><span class="s1">&#39;ymin&#39;</span><span class="p">])</span> <span class="o">*</span>
                                     <span class="p">(</span><span class="n">iterInfo</span><span class="p">[</span><span class="s1">&#39;xmax&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">iterInfo</span><span class="p">[</span><span class="s1">&#39;xmin&#39;</span><span class="p">])),</span>
                    <span class="p">},</span>
                    <span class="s1">&#39;iterator_range&#39;</span><span class="p">:</span> <span class="p">{</span>
                        <span class="s1">&#39;level_x_min&#39;</span><span class="p">:</span> <span class="n">iterInfo</span><span class="p">[</span><span class="s1">&#39;xmin&#39;</span><span class="p">],</span>
                        <span class="s1">&#39;level_y_min&#39;</span><span class="p">:</span> <span class="n">iterInfo</span><span class="p">[</span><span class="s1">&#39;ymin&#39;</span><span class="p">],</span>
                        <span class="s1">&#39;level_x_max&#39;</span><span class="p">:</span> <span class="n">iterInfo</span><span class="p">[</span><span class="s1">&#39;xmax&#39;</span><span class="p">],</span>
                        <span class="s1">&#39;level_y_max&#39;</span><span class="p">:</span> <span class="n">iterInfo</span><span class="p">[</span><span class="s1">&#39;ymax&#39;</span><span class="p">],</span>
                        <span class="s1">&#39;region_x_max&#39;</span><span class="p">:</span> <span class="n">iterInfo</span><span class="p">[</span><span class="s1">&#39;xmax&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">iterInfo</span><span class="p">[</span><span class="s1">&#39;xmin&#39;</span><span class="p">],</span>
                        <span class="s1">&#39;region_y_max&#39;</span><span class="p">:</span> <span class="n">iterInfo</span><span class="p">[</span><span class="s1">&#39;ymax&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">iterInfo</span><span class="p">[</span><span class="s1">&#39;ymin&#39;</span><span class="p">],</span>
                        <span class="s1">&#39;position&#39;</span><span class="p">:</span> <span class="p">((</span><span class="n">iterInfo</span><span class="p">[</span><span class="s1">&#39;xmax&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">iterInfo</span><span class="p">[</span><span class="s1">&#39;xmin&#39;</span><span class="p">])</span> <span class="o">*</span>
                                     <span class="p">(</span><span class="n">iterInfo</span><span class="p">[</span><span class="s1">&#39;ymax&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">iterInfo</span><span class="p">[</span><span class="s1">&#39;ymin&#39;</span><span class="p">]))</span>
                    <span class="p">},</span>
                    <span class="s1">&#39;tile_overlap&#39;</span><span class="p">:</span> <span class="n">overlap</span>
                <span class="p">})</span>
                <span class="n">tile</span><span class="p">[</span><span class="s1">&#39;gx&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tile</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">scale</span>
                <span class="n">tile</span><span class="p">[</span><span class="s1">&#39;gy&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tile</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">scale</span>
                <span class="n">tile</span><span class="p">[</span><span class="s1">&#39;gwidth&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tile</span><span class="p">[</span><span class="s1">&#39;width&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">scale</span>
                <span class="n">tile</span><span class="p">[</span><span class="s1">&#39;gheight&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tile</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">scale</span>
                <span class="k">yield</span> <span class="n">tile</span>

    <span class="k">def</span> <span class="nf">_pilFormatMatches</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">match</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine if the specified PIL image matches the format of the tile</span>
<span class="sd">        source with the specified arguments.</span>

<span class="sd">        :param image: the PIL image to check.</span>
<span class="sd">        :param match: if &#39;any&#39;, all image encodings are considered matching,</span>
<span class="sd">            if &#39;encoding&#39;, then a matching encoding matches regardless of</span>
<span class="sd">            quality options, otherwise, only match if the encoding and quality</span>
<span class="sd">            options match.</span>
<span class="sd">        :param kwargs: additional parameters to use in determining format.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">encoding</span> <span class="o">=</span> <span class="n">TileOutputPILFormat</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">encoding</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">encoding</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">match</span> <span class="o">==</span> <span class="s1">&#39;any&#39;</span> <span class="ow">and</span> <span class="n">encoding</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;PNG&#39;</span><span class="p">,</span> <span class="s1">&#39;JPEG&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">image</span><span class="o">.</span><span class="n">format</span> <span class="o">!=</span> <span class="n">encoding</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">encoding</span> <span class="o">==</span> <span class="s1">&#39;PNG&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">encoding</span> <span class="o">==</span> <span class="s1">&#39;JPEG&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">match</span> <span class="o">==</span> <span class="s1">&#39;encoding&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="n">originalQuality</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">image</span><span class="o">.</span><span class="n">format</span> <span class="o">==</span> <span class="s1">&#39;JPEG&#39;</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="s1">&#39;quantization&#39;</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">image</span><span class="o">.</span><span class="n">quantization</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">58</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">100</span><span class="p">:</span>
                        <span class="n">originalQuality</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">100</span> <span class="o">-</span> <span class="n">image</span><span class="o">.</span><span class="n">quantization</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">58</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">originalQuality</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">5000.0</span> <span class="o">/</span> <span class="mf">2.5</span> <span class="o">/</span> <span class="n">image</span><span class="o">.</span><span class="n">quantization</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">15</span><span class="p">])</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">originalQuality</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">jpegQuality</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span>
        <span class="c1"># We fail for the TIFF file format; it is general enough that ensuring</span>
        <span class="c1"># compatibility could be an issue.</span>
        <span class="k">return</span> <span class="kc">False</span>

<div class="viewcode-block" id="TileSource.histogram"><a class="viewcode-back" href="../../../large_image/large_image.tilesource.html#large_image.tilesource.base.TileSource.histogram">[docs]</a>    <span class="nd">@methodcache</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">histogram</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">onlyMinMax</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">256</span><span class="p">,</span>
                  <span class="n">density</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a histogram for a region.</span>

<span class="sd">        :param dtype: if specified, the tiles must be this numpy.dtype.</span>
<span class="sd">        :param onlyMinMax: if True, only return the minimum and maximum value</span>
<span class="sd">            of the region.</span>
<span class="sd">        :param bins: the number of bins in the histogram.  This is passed to</span>
<span class="sd">            numpy.histogram, but needs to produce the same set of edges for</span>
<span class="sd">            each tile.</span>
<span class="sd">        :param density: if True, scale the results based on the number of</span>
<span class="sd">            samples.</span>
<span class="sd">        :param format: ignored.  Used to override the format for the</span>
<span class="sd">            tileIterator.</span>
<span class="sd">        :param range: if None, use the computed min and (max + 1).  Otherwise,</span>
<span class="sd">            this is the range passed to numpy.histogram.  Note this is only</span>
<span class="sd">            accessible via kwargs as it otherwise overloads the range function.</span>
<span class="sd">        :param args: parameters to pass to the tileIterator.</span>
<span class="sd">        :param kwargs: parameters to pass to the tileIterator.</span>
<span class="sd">        :returns: if onlyMinMax is true, this is a dictionary with keys min and</span>
<span class="sd">            max, each of which is a numpy array with the minimum and maximum of</span>
<span class="sd">            all of the bands.  If onlyMinMax is False, this is a dictionary</span>
<span class="sd">            with a single key &#39;histogram&#39; that contains a list of histograms</span>
<span class="sd">            per band.  Each entry is a dictionary with min, max, range, hist,</span>
<span class="sd">            and bin_edges.  range is [min, (max + 1)].  hist is the counts</span>
<span class="sd">            (normalized if density is True) for each bin.  bin_edges is an</span>
<span class="sd">            array one longer than the hist array that contains the boundaries</span>
<span class="sd">            between bins.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">histRange</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;range&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">results</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">tile</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tileIterator</span><span class="p">(</span><span class="nb">format</span><span class="o">=</span><span class="n">TILE_FORMAT_NUMPY</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">tile</span> <span class="o">=</span> <span class="n">tile</span><span class="p">[</span><span class="s1">&#39;tile&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">tile</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">dtype</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">tile</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">numpy</span><span class="o">.</span><span class="n">uint8</span> <span class="ow">and</span> <span class="n">dtype</span> <span class="o">==</span> <span class="n">numpy</span><span class="o">.</span><span class="n">uint16</span><span class="p">:</span>
                    <span class="n">tile</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">tile</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">uint16</span><span class="p">)</span> <span class="o">*</span> <span class="mi">257</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">continue</span>
            <span class="n">tilemin</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
                <span class="n">numpy</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">tile</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">idx</span><span class="p">])</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])],</span> <span class="n">tile</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">tilemax</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
                <span class="n">numpy</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">tile</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">idx</span><span class="p">])</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])],</span> <span class="n">tile</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">tilesum</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
                <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">tile</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">idx</span><span class="p">])</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])],</span> <span class="nb">float</span><span class="p">)</span>
            <span class="n">tilesum2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
                <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">tile</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">idx</span><span class="p">],</span> <span class="nb">float</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])],</span> <span class="nb">float</span><span class="p">)</span>
            <span class="n">tilecount</span> <span class="o">=</span> <span class="n">tile</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">tile</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">results</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">results</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s1">&#39;min&#39;</span><span class="p">:</span> <span class="n">tilemin</span><span class="p">,</span>
                    <span class="s1">&#39;max&#39;</span><span class="p">:</span> <span class="n">tilemax</span><span class="p">,</span>
                    <span class="s1">&#39;sum&#39;</span><span class="p">:</span> <span class="n">tilesum</span><span class="p">,</span>
                    <span class="s1">&#39;sum2&#39;</span><span class="p">:</span> <span class="n">tilesum2</span><span class="p">,</span>
                    <span class="s1">&#39;count&#39;</span><span class="p">:</span> <span class="n">tilecount</span>
                <span class="p">}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">results</span><span class="p">[</span><span class="s1">&#39;min&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;min&#39;</span><span class="p">],</span> <span class="n">tilemin</span><span class="p">)</span>
                <span class="n">results</span><span class="p">[</span><span class="s1">&#39;max&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;max&#39;</span><span class="p">],</span> <span class="n">tilemax</span><span class="p">)</span>
                <span class="n">results</span><span class="p">[</span><span class="s1">&#39;sum&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">tilesum</span>
                <span class="n">results</span><span class="p">[</span><span class="s1">&#39;sum2&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">tilesum2</span>
                <span class="n">results</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">tilecount</span>
        <span class="n">results</span><span class="p">[</span><span class="s1">&#39;mean&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;sum&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">]</span>
        <span class="n">results</span><span class="p">[</span><span class="s1">&#39;stdev&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;sum2&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;mean&#39;</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span>
            <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;sum2&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mf">0.5</span>
        <span class="n">results</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;sum&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">results</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;sum2&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">results</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;count&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">results</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">onlyMinMax</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">results</span>
        <span class="n">results</span><span class="p">[</span><span class="s1">&#39;histogram&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[{</span>
            <span class="s1">&#39;min&#39;</span><span class="p">:</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;min&#39;</span><span class="p">][</span><span class="n">idx</span><span class="p">],</span>
            <span class="s1">&#39;max&#39;</span><span class="p">:</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;max&#39;</span><span class="p">][</span><span class="n">idx</span><span class="p">],</span>
            <span class="s1">&#39;mean&#39;</span><span class="p">:</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;mean&#39;</span><span class="p">][</span><span class="n">idx</span><span class="p">],</span>
            <span class="s1">&#39;stdev&#39;</span><span class="p">:</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;stdev&#39;</span><span class="p">][</span><span class="n">idx</span><span class="p">],</span>
            <span class="s1">&#39;range&#39;</span><span class="p">:</span> <span class="p">((</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;min&#39;</span><span class="p">][</span><span class="n">idx</span><span class="p">],</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;max&#39;</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                      <span class="k">if</span> <span class="n">histRange</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">histRange</span><span class="p">),</span>
            <span class="s1">&#39;hist&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s1">&#39;bin_edges&#39;</span><span class="p">:</span> <span class="kc">None</span>
        <span class="p">}</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;min&#39;</span><span class="p">]))]</span>
        <span class="k">for</span> <span class="n">tile</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tileIterator</span><span class="p">(</span><span class="nb">format</span><span class="o">=</span><span class="n">TILE_FORMAT_NUMPY</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">tile</span> <span class="o">=</span> <span class="n">tile</span><span class="p">[</span><span class="s1">&#39;tile&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">tile</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">dtype</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">tile</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">numpy</span><span class="o">.</span><span class="n">uint8</span> <span class="ow">and</span> <span class="n">dtype</span> <span class="o">==</span> <span class="n">numpy</span><span class="o">.</span><span class="n">uint16</span><span class="p">:</span>
                    <span class="n">tile</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">tile</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">uint16</span><span class="p">)</span> <span class="o">*</span> <span class="mi">257</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">continue</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;min&#39;</span><span class="p">])):</span>
                <span class="n">entry</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;histogram&#39;</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span>
                <span class="n">hist</span><span class="p">,</span> <span class="n">bin_edges</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span>
                    <span class="n">tile</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">idx</span><span class="p">],</span> <span class="n">bins</span><span class="p">,</span> <span class="n">entry</span><span class="p">[</span><span class="s1">&#39;range&#39;</span><span class="p">],</span> <span class="n">density</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">entry</span><span class="p">[</span><span class="s1">&#39;hist&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">entry</span><span class="p">[</span><span class="s1">&#39;hist&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hist</span>
                    <span class="n">entry</span><span class="p">[</span><span class="s1">&#39;bin_edges&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">bin_edges</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">entry</span><span class="p">[</span><span class="s1">&#39;hist&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">hist</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;min&#39;</span><span class="p">])):</span>
            <span class="n">entry</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;histogram&#39;</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">entry</span><span class="p">[</span><span class="s1">&#39;hist&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">entry</span><span class="p">[</span><span class="s1">&#39;samples&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">entry</span><span class="p">[</span><span class="s1">&#39;hist&#39;</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">density</span><span class="p">:</span>
                    <span class="n">entry</span><span class="p">[</span><span class="s1">&#39;hist&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">entry</span><span class="p">[</span><span class="s1">&#39;hist&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span> <span class="o">/</span> <span class="n">entry</span><span class="p">[</span><span class="s1">&#39;samples&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">results</span></div>

    <span class="k">def</span> <span class="nf">_unstyledClassKey</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a class key that doesn&#39;t use style.  If already created, just</span>
<span class="sd">        return the created value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_classkey_unstyled&#39;</span><span class="p">):</span>
            <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_classkey</span>
            <span class="k">if</span> <span class="s1">&#39;__STYLEEND__&#39;</span> <span class="ow">in</span> <span class="n">key</span><span class="p">:</span>
                <span class="n">parts</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;__STYLEEND__&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;__STYLESTART__&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">key</span> <span class="o">+=</span> <span class="s1">&#39;__unstyled&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_classkey_unstyled</span> <span class="o">=</span> <span class="n">key</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_classkey_unstyled</span>

    <span class="k">def</span> <span class="nf">_scanForMinMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">frame</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">analysisSize</span><span class="o">=</span><span class="mi">1024</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Scan the image at a lower resolution to find the minimum and maximum</span>
<span class="sd">        values.</span>

<span class="sd">        :param dtype: the numpy dtype.  Used for guessing the range.</span>
<span class="sd">        :param frame: the frame to use for auto-ranging.</span>
<span class="sd">        :param analysisSize: the size of the image to use for analysis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_skipStyle</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># Divert the tile cache while querying unstyled tiles</span>
        <span class="n">classkey</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_classkey</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_classkey</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unstyledClassKey</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bandRanges</span><span class="p">[</span><span class="n">frame</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span>
                <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
                <span class="n">onlyMinMax</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">output</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;maxWidth&#39;</span><span class="p">:</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sizeX</span><span class="p">,</span> <span class="n">analysisSize</span><span class="p">),</span>
                        <span class="s1">&#39;maxHeight&#39;</span><span class="p">:</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sizeY</span><span class="p">,</span> <span class="n">analysisSize</span><span class="p">)},</span>
                <span class="n">resample</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">frame</span><span class="o">=</span><span class="n">frame</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bandRanges</span><span class="p">[</span><span class="n">frame</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Style range is </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bandRanges</span><span class="p">[</span><span class="n">frame</span><span class="p">])</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skipStyle</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_classkey</span> <span class="o">=</span> <span class="n">classkey</span>

    <span class="k">def</span> <span class="nf">_getMinMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">minmax</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">bandidx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">frame</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get an appropriate minimum or maximum for a band.</span>

<span class="sd">        :param minmax: either &#39;min&#39; or &#39;max&#39;.</span>
<span class="sd">        :param value: the specified value, &#39;auto&#39;, &#39;min&#39;, or &#39;max&#39;.  &#39;auto&#39;</span>
<span class="sd">            uses the parameter specified in &#39;minmax&#39; or 0 or 255 if the</span>
<span class="sd">            band&#39;s minimum is in the range [0, 254] and maximum is in the range</span>
<span class="sd">            [2, 255].</span>
<span class="sd">        :param dtype: the numpy dtype.  Used for guessing the range.</span>
<span class="sd">        :param bandidx: the index of the channel that could be used for</span>
<span class="sd">            determining the min or max.</span>
<span class="sd">        :param frame: the frame to use for auto-ranging.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">frame</span> <span class="o">=</span> <span class="n">frame</span> <span class="ow">or</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;min&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span><span class="p">,</span> <span class="s1">&#39;auto&#39;</span><span class="p">}:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Style min/max value of </span><span class="si">%r</span><span class="s1"> is not valid; using &quot;auto&quot;&#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
                <span class="n">value</span> <span class="o">=</span> <span class="s1">&#39;auto&#39;</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;min&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span><span class="p">,</span> <span class="s1">&#39;auto&#39;</span><span class="p">}</span> <span class="ow">and</span> <span class="n">frame</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bandRanges</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_scanForMinMax</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">frame</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="s1">&#39;auto&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bandRanges</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span> <span class="ow">and</span>
                    <span class="n">numpy</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bandRanges</span><span class="p">[</span><span class="n">frame</span><span class="p">][</span><span class="s1">&#39;min&#39;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span>
                    <span class="n">numpy</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bandRanges</span><span class="p">[</span><span class="n">frame</span><span class="p">][</span><span class="s1">&#39;min&#39;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">254</span><span class="p">)</span> <span class="ow">and</span>
                    <span class="n">numpy</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bandRanges</span><span class="p">[</span><span class="n">frame</span><span class="p">][</span><span class="s1">&#39;max&#39;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="ow">and</span>
                    <span class="n">numpy</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bandRanges</span><span class="p">[</span><span class="n">frame</span><span class="p">][</span><span class="s1">&#39;max&#39;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">255</span><span class="p">)):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">minmax</span> <span class="o">==</span> <span class="s1">&#39;min&#39;</span> <span class="k">else</span> <span class="mi">255</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">minmax</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="s1">&#39;min&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">bandidx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bandRanges</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">frame</span><span class="p">):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bandRanges</span><span class="p">[</span><span class="n">frame</span><span class="p">][</span><span class="s1">&#39;min&#39;</span><span class="p">][</span><span class="n">bandidx</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="n">value</span> <span class="o">==</span> <span class="s1">&#39;max&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">bandidx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bandRanges</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">frame</span><span class="p">):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bandRanges</span><span class="p">[</span><span class="n">frame</span><span class="p">][</span><span class="s1">&#39;max&#39;</span><span class="p">][</span><span class="n">bandidx</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">dtype</span> <span class="o">==</span> <span class="n">numpy</span><span class="o">.</span><span class="n">uint16</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="mi">65535</span>
            <span class="k">elif</span> <span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;f&#39;</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="mi">255</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_applyStyle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">style</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">frame</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>  <span class="c1"># noqa</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply a style to a numpy image.</span>

<span class="sd">        :param image: the image to modify.</span>
<span class="sd">        :param style: a style object.</span>
<span class="sd">        :param x: the x tile position; used for multi-frame styles.</span>
<span class="sd">        :param y: the y tile position; used for multi-frame styles.</span>
<span class="sd">        :param z: the z tile position; used for multi-frame styles.</span>
<span class="sd">        :param frame: the frame to use for auto ranging.</span>
<span class="sd">        :returns: a styled image.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">style</span> <span class="o">=</span> <span class="n">style</span><span class="p">[</span><span class="s1">&#39;bands&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;bands&#39;</span> <span class="ow">in</span> <span class="n">style</span> <span class="k">else</span> <span class="p">[</span><span class="n">style</span><span class="p">]</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">4</span><span class="p">),</span> <span class="nb">float</span><span class="p">)</span>
        <span class="n">mainImage</span> <span class="o">=</span> <span class="n">image</span>
        <span class="n">mainFrame</span> <span class="o">=</span> <span class="n">frame</span>
        <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">style</span><span class="p">:</span>
            <span class="n">bandidx</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="k">else</span> <span class="mi">1</span>
            <span class="n">band</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">entry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;frame&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">entry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;framedelta&#39;</span><span class="p">))</span> <span class="ow">or</span>
                    <span class="n">entry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;frame&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="n">frame</span><span class="p">):</span>
                <span class="n">image</span> <span class="o">=</span> <span class="n">mainImage</span>
                <span class="n">frame</span> <span class="o">=</span> <span class="n">mainFrame</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">frame</span> <span class="o">=</span> <span class="n">entry</span><span class="p">[</span><span class="s1">&#39;frame&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="n">entry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;frame&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">(</span>
                    <span class="n">mainFrame</span> <span class="o">+</span> <span class="n">entry</span><span class="p">[</span><span class="s1">&#39;framedelta&#39;</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_skipStyle</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="c1"># Divert the tile cache while querying unstyled tiles</span>
                <span class="n">classkey</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_classkey</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_classkey</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unstyledClassKey</span><span class="p">()</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">image</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getTile</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">frame</span><span class="o">=</span><span class="n">frame</span><span class="p">,</span> <span class="n">numpyAllowed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="p">[:</span><span class="n">mainImage</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:</span><span class="n">mainImage</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">:</span><span class="n">mainImage</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
                <span class="k">finally</span><span class="p">:</span>
                    <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skipStyle</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_classkey</span> <span class="o">=</span> <span class="n">classkey</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">entry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;band&#39;</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span>
                    <span class="n">entry</span><span class="p">[</span><span class="s1">&#39;band&#39;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">entry</span><span class="p">[</span><span class="s1">&#39;band&#39;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span>
                <span class="n">bandidx</span> <span class="o">=</span> <span class="n">entry</span><span class="p">[</span><span class="s1">&#39;band&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">composite</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;composite&#39;</span><span class="p">,</span> <span class="s1">&#39;lighten&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_bandnames&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">entry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;band&#39;</span><span class="p">)</span> <span class="ow">and</span>
                    <span class="nb">str</span><span class="p">(</span><span class="n">entry</span><span class="p">[</span><span class="s1">&#39;band&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bandnames</span> <span class="ow">and</span>
                    <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bandnames</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">entry</span><span class="p">[</span><span class="s1">&#39;band&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">lower</span><span class="p">()]):</span>
                <span class="n">bandidx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bandnames</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">entry</span><span class="p">[</span><span class="s1">&#39;band&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">lower</span><span class="p">()]</span>
            <span class="k">if</span> <span class="n">entry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;band&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;red&#39;</span> <span class="ow">and</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">bandidx</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">elif</span> <span class="n">entry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;band&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;blue&#39;</span> <span class="ow">and</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">bandidx</span> <span class="o">=</span> <span class="mi">2</span>
                <span class="n">band</span> <span class="o">=</span> <span class="n">image</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">2</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">entry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;band&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;alpha&#39;</span><span class="p">:</span>
                <span class="n">bandidx</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>
                <span class="n">band</span> <span class="o">=</span> <span class="p">(</span><span class="n">image</span><span class="p">[:,</span> <span class="p">:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="k">else</span>
                        <span class="n">numpy</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span> <span class="mi">255</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">uint8</span><span class="p">))</span>
                <span class="n">composite</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;composite&#39;</span><span class="p">,</span> <span class="s1">&#39;multiply&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">band</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">band</span> <span class="o">=</span> <span class="n">image</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">bandidx</span><span class="p">]</span>
            <span class="n">palette</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
                <span class="n">PIL</span><span class="o">.</span><span class="n">ImageColor</span><span class="o">.</span><span class="n">getcolor</span><span class="p">(</span><span class="n">clr</span><span class="p">,</span> <span class="s1">&#39;RGBA&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">clr</span> <span class="ow">in</span> <span class="n">entry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                    <span class="s1">&#39;palette&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;#000&#39;</span><span class="p">,</span> <span class="s1">&#39;#FFF&#39;</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">entry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;band&#39;</span><span class="p">)</span> <span class="o">!=</span> <span class="s1">&#39;alpha&#39;</span> <span class="k">else</span> <span class="p">[</span><span class="s1">&#39;#FFF0&#39;</span><span class="p">,</span> <span class="s1">&#39;#FFFF&#39;</span><span class="p">])])</span>
            <span class="n">palettebase</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">palette</span><span class="p">),</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">nodata</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;nodata&#39;</span><span class="p">)</span>
            <span class="nb">min</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getMinMax</span><span class="p">(</span><span class="s1">&#39;min&#39;</span><span class="p">,</span> <span class="n">entry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;min&#39;</span><span class="p">,</span> <span class="s1">&#39;auto&#39;</span><span class="p">),</span> <span class="n">image</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">bandidx</span><span class="p">,</span> <span class="n">frame</span><span class="p">)</span>
            <span class="nb">max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getMinMax</span><span class="p">(</span><span class="s1">&#39;max&#39;</span><span class="p">,</span> <span class="n">entry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;max&#39;</span><span class="p">,</span> <span class="s1">&#39;auto&#39;</span><span class="p">),</span> <span class="n">image</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">bandidx</span><span class="p">,</span> <span class="n">frame</span><span class="p">)</span>
            <span class="n">clamp</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;clamp&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="nb">max</span> <span class="o">-</span> <span class="nb">min</span> <span class="k">if</span> <span class="nb">max</span> <span class="o">!=</span> <span class="nb">min</span> <span class="k">else</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">nodata</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">keep</span> <span class="o">=</span> <span class="n">band</span> <span class="o">!=</span> <span class="n">nodata</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">keep</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span> <span class="kc">True</span><span class="p">)</span>
            <span class="n">band</span> <span class="o">=</span> <span class="p">(</span><span class="n">band</span> <span class="o">-</span> <span class="nb">min</span><span class="p">)</span> <span class="o">/</span> <span class="n">delta</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">clamp</span><span class="p">:</span>
                <span class="n">keep</span> <span class="o">=</span> <span class="n">keep</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">band</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">band</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">palette</span><span class="p">[:,</span> <span class="n">channel</span><span class="p">]</span> <span class="o">==</span> <span class="n">palette</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">channel</span><span class="p">]):</span>
                    <span class="k">if</span> <span class="p">((</span><span class="n">palette</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">channel</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">composite</span> <span class="o">!=</span> <span class="s1">&#39;multiply&#39;</span><span class="p">)</span> <span class="ow">or</span>
                            <span class="p">(</span><span class="n">palette</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">channel</span><span class="p">]</span> <span class="o">==</span> <span class="mi">255</span> <span class="ow">and</span> <span class="n">composite</span> <span class="o">==</span> <span class="s1">&#39;multiply&#39;</span><span class="p">)):</span>
                        <span class="k">continue</span>
                    <span class="n">clrs</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">band</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">palette</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">channel</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">band</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Don&#39;t recompute if the palette is repeated two channels</span>
                    <span class="c1"># in a row.</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">channel</span> <span class="ow">or</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">palette</span><span class="p">[:,</span> <span class="n">channel</span><span class="p">]</span> <span class="o">!=</span> <span class="n">palette</span><span class="p">[:,</span> <span class="n">channel</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]):</span>
                        <span class="n">clrs</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">band</span><span class="p">,</span> <span class="n">palettebase</span><span class="p">,</span> <span class="n">palette</span><span class="p">[:,</span> <span class="n">channel</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">composite</span> <span class="o">==</span> <span class="s1">&#39;multiply&#39;</span><span class="p">:</span>
                    <span class="n">output</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">channel</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span>
                        <span class="n">output</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">channel</span><span class="p">],</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">keep</span><span class="p">,</span> <span class="n">clrs</span> <span class="o">/</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">output</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">channel</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span>
                        <span class="n">output</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">channel</span><span class="p">],</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">keep</span><span class="p">,</span> <span class="n">clrs</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">output</span>

    <span class="k">def</span> <span class="nf">_outputTileNumpyStyle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tile</span><span class="p">,</span> <span class="n">applyStyle</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">frame</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert a tile to a numpy array.  Optionally apply the style to a tile.</span>
<span class="sd">        Always returns a numpy tile.</span>

<span class="sd">        :param tile: the tile to convert.</span>
<span class="sd">        :param applyStyle: if True and there is a style, apply it.</span>
<span class="sd">        :param x: the x tile position; used for multi-frame styles.</span>
<span class="sd">        :param y: the y tile position; used for multi-frame styles.</span>
<span class="sd">        :param z: the z tile position; used for multi-frame styles.</span>
<span class="sd">        :param frame: the frame to use for auto-ranging.</span>
<span class="sd">        :returns: a numpy array and a target PIL image mode.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tile</span><span class="p">,</span> <span class="n">mode</span> <span class="o">=</span> <span class="n">_imageToNumpy</span><span class="p">(</span><span class="n">tile</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">applyStyle</span> <span class="ow">and</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;style&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_styleLock</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_skipStyle&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
                    <span class="n">tile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_applyStyle</span><span class="p">(</span><span class="n">tile</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">style</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">frame</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">tile</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tileHeight</span> <span class="ow">or</span> <span class="n">tile</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tileWidth</span><span class="p">:</span>
            <span class="n">extend</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tileHeight</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tileWidth</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
                <span class="n">dtype</span><span class="o">=</span><span class="n">tile</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">extend</span><span class="p">[:</span><span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tileHeight</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                   <span class="p">:</span><span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tileWidth</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span> <span class="o">=</span> <span class="n">tile</span>
            <span class="n">tile</span> <span class="o">=</span> <span class="n">extend</span>
        <span class="k">return</span> <span class="n">tile</span><span class="p">,</span> <span class="n">mode</span>

    <span class="k">def</span> <span class="nf">_outputTile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tile</span><span class="p">,</span> <span class="n">tileEncoding</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">pilImageAllowed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">numpyAllowed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">applyStyle</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert a tile from a numpy array, PIL image, or image in memory to the</span>
<span class="sd">        desired encoding.</span>

<span class="sd">        :param tile: the tile to convert.</span>
<span class="sd">        :param tileEncoding: the current tile encoding.</span>
<span class="sd">        :param x: tile x value.  Used for cropping or edge adjustment.</span>
<span class="sd">        :param y: tile y value.  Used for cropping or edge adjustment.</span>
<span class="sd">        :param z: tile z (level) value.  Used for cropping or edge adjustment.</span>
<span class="sd">        :param pilImageAllowed: True if a PIL image may be returned.</span>
<span class="sd">        :param numpyAllowed: True if a numpy image may be returned.  &#39;always&#39;</span>
<span class="sd">            to return a numpy array.</span>
<span class="sd">        :param applyStyle: if True and there is a style, apply it.</span>
<span class="sd">        :returns: either a numpy array, a PIL image, or a memory object with an</span>
<span class="sd">            image file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">isEdge</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge</span><span class="p">:</span>
            <span class="n">sizeX</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sizeX</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="n">z</span> <span class="o">-</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">levels</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span>
            <span class="n">sizeY</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sizeY</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="n">z</span> <span class="o">-</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">levels</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span>
            <span class="n">maxX</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">tileWidth</span>
            <span class="n">maxY</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">tileHeight</span>
            <span class="n">isEdge</span> <span class="o">=</span> <span class="n">maxX</span> <span class="o">&gt;</span> <span class="n">sizeX</span> <span class="ow">or</span> <span class="n">maxY</span> <span class="o">&gt;</span> <span class="n">sizeY</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">tileEncoding</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="n">TILE_FORMAT_PIL</span><span class="p">,</span> <span class="n">TILE_FORMAT_NUMPY</span><span class="p">)</span> <span class="ow">and</span>
                <span class="n">numpyAllowed</span> <span class="o">!=</span> <span class="s1">&#39;always&#39;</span> <span class="ow">and</span> <span class="n">tileEncoding</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">encoding</span> <span class="ow">and</span>
                <span class="ow">not</span> <span class="n">isEdge</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">applyStyle</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;style&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))):</span>
            <span class="k">return</span> <span class="n">tile</span>
        <span class="n">mode</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">numpyAllowed</span> <span class="o">==</span> <span class="s1">&#39;always&#39;</span> <span class="ow">or</span> <span class="n">tileEncoding</span> <span class="o">==</span> <span class="n">TILE_FORMAT_NUMPY</span> <span class="ow">or</span>
                <span class="p">(</span><span class="n">applyStyle</span> <span class="ow">and</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;style&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span> <span class="ow">or</span> <span class="n">isEdge</span><span class="p">):</span>
            <span class="n">tile</span><span class="p">,</span> <span class="n">mode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_outputTileNumpyStyle</span><span class="p">(</span><span class="n">tile</span><span class="p">,</span> <span class="n">applyStyle</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;frame&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">isEdge</span><span class="p">:</span>
            <span class="n">contentWidth</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tileWidth</span><span class="p">,</span>
                               <span class="n">sizeX</span> <span class="o">-</span> <span class="p">(</span><span class="n">maxX</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">tileWidth</span><span class="p">))</span>
            <span class="n">contentHeight</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tileHeight</span><span class="p">,</span>
                                <span class="n">sizeY</span> <span class="o">-</span> <span class="p">(</span><span class="n">maxY</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">tileHeight</span><span class="p">))</span>
            <span class="n">tile</span><span class="p">,</span> <span class="n">mode</span> <span class="o">=</span> <span class="n">_imageToNumpy</span><span class="p">(</span><span class="n">tile</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="s1">&#39;crop&#39;</span><span class="p">):</span>
                <span class="n">tile</span> <span class="o">=</span> <span class="n">tile</span><span class="p">[:</span><span class="n">contentHeight</span><span class="p">,</span> <span class="p">:</span><span class="n">contentWidth</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">color</span> <span class="o">=</span> <span class="n">PIL</span><span class="o">.</span><span class="n">ImageColor</span><span class="o">.</span><span class="n">getcolor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edge</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>
                <span class="n">tile</span> <span class="o">=</span> <span class="n">tile</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">tile</span><span class="p">[:,</span> <span class="n">contentWidth</span><span class="p">:]</span> <span class="o">=</span> <span class="n">color</span>
                <span class="n">tile</span><span class="p">[</span><span class="n">contentHeight</span><span class="p">:]</span> <span class="o">=</span> <span class="n">color</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tile</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">numpyAllowed</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">tile</span>
        <span class="n">tile</span> <span class="o">=</span> <span class="n">_imageToPIL</span><span class="p">(</span><span class="n">tile</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pilImageAllowed</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">tile</span>
        <span class="n">encoding</span> <span class="o">=</span> <span class="n">TileOutputPILFormat</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">encoding</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">encoding</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">encoding</span> <span class="o">==</span> <span class="s1">&#39;JPEG&#39;</span> <span class="ow">and</span> <span class="n">tile</span><span class="o">.</span><span class="n">mode</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;L&#39;</span><span class="p">,</span> <span class="s1">&#39;RGB&#39;</span><span class="p">):</span>
            <span class="n">tile</span> <span class="o">=</span> <span class="n">tile</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="s1">&#39;RGB&#39;</span><span class="p">)</span>
        <span class="c1"># If we can&#39;t redirect, but the tile is read from a file in the desired</span>
        <span class="c1"># output format, just read the file</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">tile</span><span class="p">,</span> <span class="s1">&#39;fp&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pilFormatMatches</span><span class="p">(</span><span class="n">tile</span><span class="p">):</span>
            <span class="n">tile</span><span class="o">.</span><span class="n">fp</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">tile</span><span class="o">.</span><span class="n">fp</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">()</span>
        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">encoding</span> <span class="o">==</span> <span class="s1">&#39;JPEG&#39;</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s1">&#39;quality&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">jpegQuality</span>
            <span class="n">params</span><span class="p">[</span><span class="s1">&#39;subsampling&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">jpegSubsampling</span>
        <span class="k">elif</span> <span class="n">encoding</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;TIFF&#39;</span><span class="p">,</span> <span class="s1">&#39;TILED&#39;</span><span class="p">}:</span>
            <span class="n">params</span><span class="p">[</span><span class="s1">&#39;compression&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tiffCompression</span>
        <span class="n">tile</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">encoding</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">output</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_getAssociatedImage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">imageKey</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get an associated image in PIL format.</span>

<span class="sd">        :param imageKey: the key of the associated image.</span>
<span class="sd">        :return: the image in PIL format or None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">None</span>

<div class="viewcode-block" id="TileSource.canRead"><a class="viewcode-back" href="../../../large_image/large_image.tilesource.html#large_image.tilesource.base.TileSource.canRead">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">canRead</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if we can read the input.  This takes the same parameters as</span>
<span class="sd">        __init__.</span>

<span class="sd">        :returns: True if this class can read the input.  False if it cannot.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="TileSource.getMetadata"><a class="viewcode-back" href="../../../large_image/large_image.tilesource.html#large_image.tilesource.base.TileSource.getMetadata">[docs]</a>    <span class="k">def</span> <span class="nf">getMetadata</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return metadata about this tile source.  This contains</span>

<span class="sd">            :levels: number of tile levels in this image.</span>
<span class="sd">            :sizeX: width of the image in pixels.</span>
<span class="sd">            :sizeY: height of the image in pixels.</span>
<span class="sd">            :tileWidth: width of a tile in pixels.</span>
<span class="sd">            :tileHeight: height of a tile in pixels.</span>
<span class="sd">            :magnification: if known, the magnificaiton of the image.</span>
<span class="sd">            :mm_x: if known, the width of a pixel in millimeters.</span>
<span class="sd">            :mm_y: if known, the height of a pixel in millimeters.</span>

<span class="sd">            In addition to the keys that listed above, tile sources that expose</span>
<span class="sd">            multiple frames will also contain</span>

<span class="sd">            :frames: a list of frames.  Each frame entry is a dictionary with</span>

<span class="sd">                :Frame: a 0-values frame index (the location in the list)</span>
<span class="sd">                :Channel: optional.  The name of the channel, if known</span>
<span class="sd">                :IndexC: optional if unique.  A 0-based index into the channel</span>
<span class="sd">                    list</span>
<span class="sd">                :IndexT: optional if unique.  A 0-based index for time values</span>
<span class="sd">                :IndexZ: optional if unique.  A 0-based index for z values</span>
<span class="sd">                :IndexXY: optional if unique.  A 0-based index for view (xy)</span>
<span class="sd">                    values</span>
<span class="sd">                :Index: a 0-based index of non-channel unique sets.  If the</span>
<span class="sd">                    frames vary only by channel and are adjacent, they will</span>
<span class="sd">                    have the same index.</span>

<span class="sd">            :IndexRange: a dictionary of the number of unique index values from</span>
<span class="sd">                frames if greater than 1 (e.g., if an entry like IndexXY is not</span>
<span class="sd">                present, then all frames either do not have that value or have</span>
<span class="sd">                a value of 0).</span>
<span class="sd">            :channels: optional.  If known, a list of channel names</span>
<span class="sd">            :channelmap: optional.  If known, a dictionary of channel names</span>
<span class="sd">                with their offset into the channel list.</span>

<span class="sd">        Note that this does nto include band information, though some tile</span>
<span class="sd">        sources may do so.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNativeMagnification</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;levels&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">,</span>
            <span class="s1">&#39;sizeX&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">sizeX</span><span class="p">,</span>
            <span class="s1">&#39;sizeY&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">sizeY</span><span class="p">,</span>
            <span class="s1">&#39;tileWidth&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">tileWidth</span><span class="p">,</span>
            <span class="s1">&#39;tileHeight&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">tileHeight</span><span class="p">,</span>
            <span class="s1">&#39;magnification&#39;</span><span class="p">:</span> <span class="n">mag</span><span class="p">[</span><span class="s1">&#39;magnification&#39;</span><span class="p">],</span>
            <span class="s1">&#39;mm_x&#39;</span><span class="p">:</span> <span class="n">mag</span><span class="p">[</span><span class="s1">&#39;mm_x&#39;</span><span class="p">],</span>
            <span class="s1">&#39;mm_y&#39;</span><span class="p">:</span> <span class="n">mag</span><span class="p">[</span><span class="s1">&#39;mm_y&#39;</span><span class="p">],</span>
        <span class="p">}</span></div>

    <span class="k">def</span> <span class="nf">_addMetadataFrameInformation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span> <span class="n">channels</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a metadata response that has a `frames` list, where each frame</span>
<span class="sd">        has some of `Index(XY|Z|C|T)`, populate the `Frame`, `Index` and</span>
<span class="sd">        possibly the `Channel` of each frame in the list and the `IndexRange`,</span>
<span class="sd">        `IndexStride`, and possibly the `channels` and `channelmap` entries of</span>
<span class="sd">        the metadata.</span>

<span class="sd">        :param metadata: the metadata response that might contain `frames`.</span>
<span class="sd">            Modified.</span>
<span class="sd">        :param channels: an optional list of channel names.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;frames&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">metadata</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">maxref</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">refkeys</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;IndexC&#39;</span><span class="p">,</span> <span class="s1">&#39;IndexZ&#39;</span><span class="p">,</span> <span class="s1">&#39;IndexXY&#39;</span><span class="p">,</span> <span class="s1">&#39;IndexT&#39;</span><span class="p">}</span>
        <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">frame</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;frames&#39;</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">refkeys</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">frame</span> <span class="ow">and</span> <span class="n">frame</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="n">maxref</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
                    <span class="n">maxref</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">frame</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">frame</span><span class="p">[</span><span class="s1">&#39;Frame&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span>
                    <span class="n">frame</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">!=</span> <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;frames&#39;</span><span class="p">][</span><span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">refkeys</span> <span class="k">if</span> <span class="n">key</span> <span class="o">!=</span> <span class="s1">&#39;IndexC&#39;</span><span class="p">):</span>
                <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">frame</span><span class="p">[</span><span class="s1">&#39;Index&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">val</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">maxref</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;IndexRange&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">value</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">maxref</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">value</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">}</span>
            <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;IndexStride&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">key</span><span class="p">:</span> <span class="p">[</span><span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">frame</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;frames&#39;</span><span class="p">])</span> <span class="k">if</span> <span class="n">frame</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;IndexRange&#39;</span><span class="p">]</span>
            <span class="p">}</span>
        <span class="k">if</span> <span class="n">channels</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">channels</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">maxref</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;IndexC&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;channels&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">channels</span><span class="p">[:</span><span class="n">maxref</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;IndexC&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>
            <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;channelmap&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">cname</span><span class="p">:</span> <span class="n">c</span> <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">cname</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">channels</span><span class="p">[:</span><span class="n">maxref</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;IndexC&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])}</span>
            <span class="k">for</span> <span class="n">frame</span> <span class="ow">in</span> <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;frames&#39;</span><span class="p">]:</span>
                <span class="n">frame</span><span class="p">[</span><span class="s1">&#39;Channel&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">channels</span><span class="p">[</span><span class="n">frame</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;IndexC&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>

<div class="viewcode-block" id="TileSource.getInternalMetadata"><a class="viewcode-back" href="../../../large_image/large_image.tilesource.html#large_image.tilesource.base.TileSource.getInternalMetadata">[docs]</a>    <span class="k">def</span> <span class="nf">getInternalMetadata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return additional known metadata about the tile source.  Data returned</span>
<span class="sd">        from this method is not guaranteed to be in any particular format or</span>
<span class="sd">        have specific values.</span>

<span class="sd">        :returns: a dictionary of data or None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="TileSource.getOneBandInformation"><a class="viewcode-back" href="../../../large_image/large_image.tilesource.html#large_image.tilesource.base.TileSource.getOneBandInformation">[docs]</a>    <span class="k">def</span> <span class="nf">getOneBandInformation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">band</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get band information for a single band.</span>

<span class="sd">        :param band: a 1-based band.</span>
<span class="sd">        :returns: a dictionary of band information.  See getBandInformation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getBandInformation</span><span class="p">()[</span><span class="n">band</span><span class="p">]</span></div>

<div class="viewcode-block" id="TileSource.getBandInformation"><a class="viewcode-back" href="../../../large_image/large_image.tilesource.html#large_image.tilesource.base.TileSource.getBandInformation">[docs]</a>    <span class="k">def</span> <span class="nf">getBandInformation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">statistics</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get information about each band in the image.</span>

<span class="sd">        :param statistics: if True, compute statistics if they don&#39;t already</span>
<span class="sd">            exist.</span>
<span class="sd">        :returns: a dictionary of one dictionary per band.  Each dictionary</span>
<span class="sd">            contains known values such as interpretation, min, max, mean,</span>
<span class="sd">            stdev.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_bandInfo&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">bandInterp</span> <span class="o">=</span> <span class="p">{</span>
                <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;gray&#39;</span><span class="p">],</span>
                <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;gray&#39;</span><span class="p">,</span> <span class="s1">&#39;alpha&#39;</span><span class="p">],</span>
                <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="s1">&#39;blue&#39;</span><span class="p">],</span>
                <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="s1">&#39;alpha&#39;</span><span class="p">]}</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">statistics</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_bandInfoNoStats&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
                    <span class="n">tile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getSingleTile</span><span class="p">()[</span><span class="s1">&#39;tile&#39;</span><span class="p">]</span>
                    <span class="n">bands</span> <span class="o">=</span> <span class="n">tile</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="k">else</span> <span class="mi">1</span>
                    <span class="n">interp</span> <span class="o">=</span> <span class="n">bandInterp</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">bands</span><span class="p">,</span> <span class="n">bandInterp</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
                    <span class="n">bandInfo</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;interpretation&#39;</span><span class="p">:</span> <span class="n">interp</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">interp</span><span class="p">)</span>
                                  <span class="k">else</span> <span class="s1">&#39;unknown&#39;</span><span class="p">}</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">bands</span><span class="p">)}</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_bandInfoNoStats</span> <span class="o">=</span> <span class="n">bandInfo</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bandInfoNoStats</span>
            <span class="n">analysisSize</span> <span class="o">=</span> <span class="mi">2048</span>
            <span class="n">histogram</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span>
                <span class="n">onlyMinMax</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">output</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;maxWidth&#39;</span><span class="p">:</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sizeX</span><span class="p">,</span> <span class="n">analysisSize</span><span class="p">),</span>
                        <span class="s1">&#39;maxHeight&#39;</span><span class="p">:</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sizeY</span><span class="p">,</span> <span class="n">analysisSize</span><span class="p">)},</span>
                <span class="n">resample</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">bands</span> <span class="o">=</span> <span class="n">histogram</span><span class="p">[</span><span class="s1">&#39;min&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">interp</span> <span class="o">=</span> <span class="n">bandInterp</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">bands</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
            <span class="n">bandInfo</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;interpretation&#39;</span><span class="p">:</span> <span class="n">interp</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">interp</span><span class="p">)</span>
                          <span class="k">else</span> <span class="s1">&#39;unknown&#39;</span><span class="p">}</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">bands</span><span class="p">)}</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;min&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span><span class="p">,</span> <span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="s1">&#39;stdev&#39;</span><span class="p">}:</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">histogram</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">bands</span><span class="p">):</span>
                        <span class="n">bandInfo</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">histogram</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bandInfo</span> <span class="o">=</span> <span class="n">bandInfo</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bandInfo</span></div>

    <span class="k">def</span> <span class="nf">_xyzInRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">frame</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">numFrames</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if a tile at x, y, z is in range based on self.levels,</span>
<span class="sd">        self.tileWidth, self.tileHeight, self.sizeX, and self.sizeY,  Raise an</span>
<span class="sd">        exception if not.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">z</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">z</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">TileSourceError</span><span class="p">(</span><span class="s1">&#39;z layer does not exist&#39;</span><span class="p">)</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">levels</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">z</span><span class="p">)</span>
        <span class="n">offsetx</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">tileWidth</span> <span class="o">*</span> <span class="n">scale</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">offsetx</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">sizeX</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">TileSourceError</span><span class="p">(</span><span class="s1">&#39;x is outside layer&#39;</span><span class="p">)</span>
        <span class="n">offsety</span> <span class="o">=</span> <span class="n">y</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">tileHeight</span> <span class="o">*</span> <span class="n">scale</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">offsety</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">sizeY</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">TileSourceError</span><span class="p">(</span><span class="s1">&#39;y is outside layer&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">frame</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">numFrames</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">frame</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">frame</span> <span class="o">&gt;=</span> <span class="n">numFrames</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">TileSourceError</span><span class="p">(</span><span class="s1">&#39;Frame does not exist&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="TileSource.getTile"><a class="viewcode-back" href="../../../large_image/large_image.tilesource.html#large_image.tilesource.base.TileSource.getTile">[docs]</a>    <span class="nd">@methodcache</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">getTile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">pilImageAllowed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">numpyAllowed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">sparseFallback</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">frame</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a tile from a tile source, returning it as an binary image, a PIL</span>
<span class="sd">        image, or a numpy array.</span>

<span class="sd">        :param x: the 0-based x position of the tile on the specified z level.</span>
<span class="sd">            0 is left.</span>
<span class="sd">        :param y: the 0-based y position of the tile on the specified z level.</span>
<span class="sd">            0 is top.</span>
<span class="sd">        :param z: the z level of the tile.  May range from [0, self.levels],</span>
<span class="sd">            where 0 is the lowest resolution, single tile for the whole source.</span>
<span class="sd">        :param pilImageAllowed: True if a PIL image may be returned.</span>
<span class="sd">        :param numpyAllowed: True if a numpy image may be returned.  &#39;always&#39;</span>
<span class="sd">            to return a numpy array.</span>
<span class="sd">        :param sparseFallback: if False and a tile doesn&#39;t exist, raise an</span>
<span class="sd">            error.  If True, check if a lower resolution tile exists, and, if</span>
<span class="sd">            so, interpolate the needed data for this tile.</span>
<span class="sd">        :param frame: the frame number within the tile source.  None is the</span>
<span class="sd">            same as 0 for multi-frame sources.</span>
<span class="sd">        :returns: either a numpy array, a PIL image, or a memory object with an</span>
<span class="sd">            image file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="TileSource.getTileMimeType"><a class="viewcode-back" href="../../../large_image/large_image.tilesource.html#large_image.tilesource.base.TileSource.getTileMimeType">[docs]</a>    <span class="k">def</span> <span class="nf">getTileMimeType</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the default mimetype for image tiles.</span>

<span class="sd">        :returns: the mime type of the tile.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">TileOutputMimeTypes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">encoding</span><span class="p">,</span> <span class="s1">&#39;image/jpeg&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="TileSource.getThumbnail"><a class="viewcode-back" href="../../../large_image/large_image.tilesource.html#large_image.tilesource.base.TileSource.getThumbnail">[docs]</a>    <span class="nd">@methodcache</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">getThumbnail</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a basic thumbnail from the current tile source.  Aspect ratio is</span>
<span class="sd">        preserved.  If neither width nor height is given, a default value is</span>
<span class="sd">        used.  If both are given, the thumbnail will be no larger than either</span>
<span class="sd">        size.  A thumbnail has the same options as a region except that it</span>
<span class="sd">        always includes the entire image and has a default size of 256 x 256.</span>

<span class="sd">        :param width: maximum width in pixels.</span>
<span class="sd">        :param height: maximum height in pixels.</span>
<span class="sd">        :param kwargs: optional arguments.  Some options are encoding,</span>
<span class="sd">            jpegQuality, jpegSubsampling, and tiffCompression.</span>
<span class="sd">        :returns: thumbData, thumbMime: the image data and the mime type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">width</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="n">width</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">))</span> <span class="ow">or</span>
                <span class="p">(</span><span class="n">height</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="n">height</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">))):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid width or height.  Minimum value is 2.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">width</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">height</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">width</span> <span class="o">=</span> <span class="n">height</span> <span class="o">=</span> <span class="mi">256</span>
        <span class="n">params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">params</span><span class="p">[</span><span class="s1">&#39;output&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;maxWidth&#39;</span><span class="p">:</span> <span class="n">width</span><span class="p">,</span> <span class="s1">&#39;maxHeight&#39;</span><span class="p">:</span> <span class="n">height</span><span class="p">}</span>
        <span class="n">params</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;region&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getRegion</span><span class="p">(</span><span class="o">**</span><span class="n">params</span><span class="p">)</span></div>

<div class="viewcode-block" id="TileSource.getPreferredLevel"><a class="viewcode-back" href="../../../large_image/large_image.tilesource.html#large_image.tilesource.base.TileSource.getPreferredLevel">[docs]</a>    <span class="k">def</span> <span class="nf">getPreferredLevel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a desired level (0 is minimum resolution, self.levels - 1 is max</span>
<span class="sd">        resolution), return the level that contains actual data that is no</span>
<span class="sd">        lower resolution.</span>

<span class="sd">        :param level: desired level</span>
<span class="sd">        :returns level: a level with actual data that is no lower resolution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">metadata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getMetadata</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;levels&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">level</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;levels&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span></div>

<div class="viewcode-block" id="TileSource.convertRegionScale"><a class="viewcode-back" href="../../../large_image/large_image.tilesource.html#large_image.tilesource.base.TileSource.convertRegionScale">[docs]</a>    <span class="k">def</span> <span class="nf">convertRegionScale</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">sourceRegion</span><span class="p">,</span> <span class="n">sourceScale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">targetScale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">targetUnits</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cropToImage</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert a region from one scale to another.</span>

<span class="sd">        :param sourceRegion: a dictionary of optional values which specify the</span>
<span class="sd">            part of an image to process.</span>

<span class="sd">            :left: the left edge (inclusive) of the region to process.</span>
<span class="sd">            :top: the top edge (inclusive) of the region to process.</span>
<span class="sd">            :right: the right edge (exclusive) of the region to process.</span>
<span class="sd">            :bottom: the bottom edge (exclusive) of the region to process.</span>
<span class="sd">            :width: the width of the region to process.</span>
<span class="sd">            :height: the height of the region to process.</span>
<span class="sd">            :units: either &#39;base_pixels&#39; (default), &#39;pixels&#39;, &#39;mm&#39;, or</span>
<span class="sd">                &#39;fraction&#39;.  base_pixels are in maximum resolution pixels.</span>
<span class="sd">                pixels is in the specified magnification pixels.  mm is in the</span>
<span class="sd">                specified magnification scale.  fraction is a scale of 0 to 1.</span>
<span class="sd">                pixels and mm are only available if the magnification and mm</span>
<span class="sd">                per pixel are defined for the image.</span>

<span class="sd">        :param sourceScale: a dictionary of optional values which specify the</span>
<span class="sd">            scale of the source region.  Required if the sourceRegion is</span>
<span class="sd">            in &quot;mag_pixels&quot; units.</span>

<span class="sd">            :magnification: the magnification ratio.</span>
<span class="sd">            :mm_x: the horizontal size of a pixel in millimeters.</span>
<span class="sd">            :mm_y: the vertical size of a pixel in millimeters.</span>

<span class="sd">        :param targetScale: a dictionary of optional values which specify the</span>
<span class="sd">            scale of the target region.  Required in targetUnits is in</span>
<span class="sd">            &quot;mag_pixels&quot; units.</span>

<span class="sd">            :magnification: the magnification ratio.</span>
<span class="sd">            :mm_x: the horizontal size of a pixel in millimeters.</span>
<span class="sd">            :mm_y: the vertical size of a pixel in millimeters.</span>

<span class="sd">        :param targetUnits: if not None, convert the region to these units.</span>
<span class="sd">            Otherwise, the units are will either be the sourceRegion units if</span>
<span class="sd">            those are not &quot;mag_pixels&quot; or base_pixels.  If &quot;mag_pixels&quot;, the</span>
<span class="sd">            targetScale must be specified.</span>
<span class="sd">        :param cropToImage: if True, don&#39;t return region coordinates outside of</span>
<span class="sd">            the image.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">units</span> <span class="o">=</span> <span class="n">sourceRegion</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;units&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">units</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">TileInputUnits</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid units </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">units</span><span class="p">)</span>
        <span class="n">units</span> <span class="o">=</span> <span class="n">TileInputUnits</span><span class="p">[</span><span class="n">units</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">targetUnits</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">targetUnits</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">TileInputUnits</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid units </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">targetUnits</span><span class="p">)</span>
            <span class="n">targetUnits</span> <span class="o">=</span> <span class="n">TileInputUnits</span><span class="p">[</span><span class="n">targetUnits</span><span class="p">]</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">units</span> <span class="o">!=</span> <span class="s1">&#39;mag_pixels&#39;</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="n">targetUnits</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">targetUnits</span> <span class="o">==</span> <span class="n">units</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">sourceRegion</span>
        <span class="n">magArgs</span> <span class="o">=</span> <span class="p">(</span><span class="n">sourceScale</span> <span class="ow">or</span> <span class="p">{})</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">magArgs</span><span class="p">[</span><span class="s1">&#39;rounding&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">magLevel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getLevelForMagnification</span><span class="p">(</span><span class="o">**</span><span class="n">magArgs</span><span class="p">)</span>
        <span class="n">mag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getMagnificationForLevel</span><span class="p">(</span><span class="n">magLevel</span><span class="p">)</span>
        <span class="n">metadata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getMetadata</span><span class="p">()</span>
        <span class="c1"># Get region in base pixels</span>
        <span class="n">left</span><span class="p">,</span> <span class="n">top</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">bottom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getRegionBounds</span><span class="p">(</span>
            <span class="n">metadata</span><span class="p">,</span> <span class="n">desiredMagnification</span><span class="o">=</span><span class="n">mag</span><span class="p">,</span> <span class="n">cropToImage</span><span class="o">=</span><span class="n">cropToImage</span><span class="p">,</span>
            <span class="o">**</span><span class="n">sourceRegion</span><span class="p">)</span>
        <span class="c1"># If requested, convert region to targetUnits</span>
        <span class="n">magArgs</span> <span class="o">=</span> <span class="p">(</span><span class="n">targetScale</span> <span class="ow">or</span> <span class="p">{})</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">magArgs</span><span class="p">[</span><span class="s1">&#39;rounding&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">magLevel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getLevelForMagnification</span><span class="p">(</span><span class="o">**</span><span class="n">magArgs</span><span class="p">)</span>
        <span class="n">desiredMagnification</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getMagnificationForLevel</span><span class="p">(</span><span class="n">magLevel</span><span class="p">)</span>
        <span class="n">scaleX</span><span class="p">,</span> <span class="n">scaleY</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scaleFromUnits</span><span class="p">(</span><span class="n">metadata</span><span class="p">,</span> <span class="n">targetUnits</span><span class="p">,</span> <span class="n">desiredMagnification</span><span class="p">)</span>
        <span class="n">left</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">/</span> <span class="n">scaleX</span>
        <span class="n">right</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">right</span><span class="p">)</span> <span class="o">/</span> <span class="n">scaleX</span>
        <span class="n">top</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">top</span><span class="p">)</span> <span class="o">/</span> <span class="n">scaleY</span>
        <span class="n">bottom</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">bottom</span><span class="p">)</span> <span class="o">/</span> <span class="n">scaleY</span>
        <span class="n">targetRegion</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;left&#39;</span><span class="p">:</span> <span class="n">left</span><span class="p">,</span>
            <span class="s1">&#39;top&#39;</span><span class="p">:</span> <span class="n">top</span><span class="p">,</span>
            <span class="s1">&#39;right&#39;</span><span class="p">:</span> <span class="n">right</span><span class="p">,</span>
            <span class="s1">&#39;bottom&#39;</span><span class="p">:</span> <span class="n">bottom</span><span class="p">,</span>
            <span class="s1">&#39;width&#39;</span><span class="p">:</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="p">,</span>
            <span class="s1">&#39;height&#39;</span><span class="p">:</span> <span class="n">bottom</span> <span class="o">-</span> <span class="n">top</span><span class="p">,</span>
            <span class="s1">&#39;units&#39;</span><span class="p">:</span> <span class="n">TileInputUnits</span><span class="p">[</span><span class="n">targetUnits</span><span class="p">],</span>
        <span class="p">}</span>
        <span class="c1"># Reduce region information to match what was supplied</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="s1">&#39;top&#39;</span><span class="p">,</span> <span class="s1">&#39;right&#39;</span><span class="p">,</span> <span class="s1">&#39;bottom&#39;</span><span class="p">,</span> <span class="s1">&#39;width&#39;</span><span class="p">,</span> <span class="s1">&#39;height&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sourceRegion</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">targetRegion</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">targetRegion</span></div>

<div class="viewcode-block" id="TileSource.getRegion"><a class="viewcode-back" href="../../../large_image/large_image.tilesource.html#large_image.tilesource.base.TileSource.getRegion">[docs]</a>    <span class="k">def</span> <span class="nf">getRegion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="p">(</span><span class="n">TILE_FORMAT_IMAGE</span><span class="p">,</span> <span class="p">),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a rectangular region from the current tile source.  Aspect ratio is</span>
<span class="sd">        preserved.  If neither width nor height is given, the original size of</span>
<span class="sd">        the highest resolution level is used.  If both are given, the returned</span>
<span class="sd">        image will be no larger than either size.</span>

<span class="sd">        :param format: the desired format or a tuple of allowed formats.</span>
<span class="sd">            Formats are members of (TILE_FORMAT_PIL, TILE_FORMAT_NUMPY,</span>
<span class="sd">            TILE_FORMAT_IMAGE).  If TILE_FORMAT_IMAGE, encoding may be</span>
<span class="sd">            specified.</span>
<span class="sd">        :param kwargs: optional arguments.  Some options are region, output,</span>
<span class="sd">            encoding, jpegQuality, jpegSubsampling, tiffCompression, fill.  See</span>
<span class="sd">            tileIterator.</span>
<span class="sd">        :returns: regionData, formatOrRegionMime: the image data and either the</span>
<span class="sd">            mime type, if the format is TILE_FORMAT_IMAGE, or the format.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">format</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">set</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
            <span class="nb">format</span> <span class="o">=</span> <span class="p">(</span><span class="nb">format</span><span class="p">,</span> <span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;tile_position&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;tile_position&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">iterInfo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tileIteratorInfo</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">iterInfo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">image</span> <span class="o">=</span> <span class="n">PIL</span><span class="o">.</span><span class="n">Image</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s1">&#39;RGB&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">_encodeImage</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="nb">format</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">regionWidth</span> <span class="o">=</span> <span class="n">iterInfo</span><span class="p">[</span><span class="s1">&#39;region&#39;</span><span class="p">][</span><span class="s1">&#39;width&#39;</span><span class="p">]</span>
        <span class="n">regionHeight</span> <span class="o">=</span> <span class="n">iterInfo</span><span class="p">[</span><span class="s1">&#39;region&#39;</span><span class="p">][</span><span class="s1">&#39;height&#39;</span><span class="p">]</span>
        <span class="n">top</span> <span class="o">=</span> <span class="n">iterInfo</span><span class="p">[</span><span class="s1">&#39;region&#39;</span><span class="p">][</span><span class="s1">&#39;top&#39;</span><span class="p">]</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">iterInfo</span><span class="p">[</span><span class="s1">&#39;region&#39;</span><span class="p">][</span><span class="s1">&#39;left&#39;</span><span class="p">]</span>
        <span class="n">mode</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">TILE_FORMAT_NUMPY</span> <span class="ow">in</span> <span class="nb">format</span> <span class="k">else</span> <span class="n">iterInfo</span><span class="p">[</span><span class="s1">&#39;mode&#39;</span><span class="p">]</span>
        <span class="n">outWidth</span> <span class="o">=</span> <span class="n">iterInfo</span><span class="p">[</span><span class="s1">&#39;output&#39;</span><span class="p">][</span><span class="s1">&#39;width&#39;</span><span class="p">]</span>
        <span class="n">outHeight</span> <span class="o">=</span> <span class="n">iterInfo</span><span class="p">[</span><span class="s1">&#39;output&#39;</span><span class="p">][</span><span class="s1">&#39;height&#39;</span><span class="p">]</span>
        <span class="n">tiled</span> <span class="o">=</span> <span class="n">TILE_FORMAT_IMAGE</span> <span class="ow">in</span> <span class="nb">format</span> <span class="ow">and</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;encoding&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;TILED&#39;</span>
        <span class="n">image</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">tile</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tileIterator</span><span class="p">(</span><span class="n">iterInfo</span><span class="p">):</span>
            <span class="c1"># Add each tile to the image</span>
            <span class="n">subimage</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_imageToNumpy</span><span class="p">(</span><span class="n">tile</span><span class="p">[</span><span class="s1">&#39;tile&#39;</span><span class="p">])</span>
            <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span> <span class="o">=</span> <span class="n">tile</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">left</span><span class="p">,</span> <span class="n">tile</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">top</span>
            <span class="k">if</span> <span class="n">x0</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">subimage</span> <span class="o">=</span> <span class="n">subimage</span><span class="p">[:,</span> <span class="o">-</span><span class="n">x0</span><span class="p">:]</span>
                <span class="n">x0</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">y0</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">subimage</span> <span class="o">=</span> <span class="n">subimage</span><span class="p">[</span><span class="o">-</span><span class="n">y0</span><span class="p">:,</span> <span class="p">:]</span>
                <span class="n">y0</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">subimage</span> <span class="o">=</span> <span class="n">subimage</span><span class="p">[:</span><span class="nb">min</span><span class="p">(</span><span class="n">subimage</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">regionHeight</span> <span class="o">-</span> <span class="n">y0</span><span class="p">),</span>
                                <span class="p">:</span><span class="nb">min</span><span class="p">(</span><span class="n">subimage</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">regionWidth</span> <span class="o">-</span> <span class="n">x0</span><span class="p">)]</span>
            <span class="n">image</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_addRegionTileToImage</span><span class="p">(</span>
                <span class="n">image</span><span class="p">,</span> <span class="n">subimage</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">regionWidth</span><span class="p">,</span> <span class="n">regionHeight</span><span class="p">,</span> <span class="n">tiled</span><span class="p">,</span> <span class="n">tile</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># Scale if we need to</span>
        <span class="n">outWidth</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">outWidth</span><span class="p">))</span>
        <span class="n">outHeight</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">outHeight</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">tiled</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_encodeTiledImage</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">outWidth</span><span class="p">,</span> <span class="n">outHeight</span><span class="p">,</span> <span class="n">iterInfo</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">outWidth</span> <span class="o">!=</span> <span class="n">regionWidth</span> <span class="ow">or</span> <span class="n">outHeight</span> <span class="o">!=</span> <span class="n">regionHeight</span><span class="p">:</span>
            <span class="n">image</span> <span class="o">=</span> <span class="n">_imageToPIL</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span>
                <span class="p">(</span><span class="n">outWidth</span><span class="p">,</span> <span class="n">outHeight</span><span class="p">),</span>
                <span class="n">PIL</span><span class="o">.</span><span class="n">Image</span><span class="o">.</span><span class="n">BICUBIC</span> <span class="k">if</span> <span class="n">outWidth</span> <span class="o">&gt;</span> <span class="n">regionWidth</span> <span class="k">else</span>
                <span class="n">PIL</span><span class="o">.</span><span class="n">Image</span><span class="o">.</span><span class="n">LANCZOS</span><span class="p">)</span>
        <span class="n">maxWidth</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;output&#39;</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;maxWidth&#39;</span><span class="p">)</span>
        <span class="n">maxHeight</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;output&#39;</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;maxHeight&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;fill&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">maxWidth</span> <span class="ow">and</span> <span class="n">maxHeight</span><span class="p">:</span>
            <span class="n">image</span> <span class="o">=</span> <span class="n">_letterboxImage</span><span class="p">(</span><span class="n">_imageToPIL</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">mode</span><span class="p">),</span> <span class="n">maxWidth</span><span class="p">,</span> <span class="n">maxHeight</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;fill&#39;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">_encodeImage</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="nb">format</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_addRegionTileToImage</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">subimage</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">tiled</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">tile</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a subtile to a larger image.</span>

<span class="sd">        :param image: the output image record.  None for not created yet.</span>
<span class="sd">        :param subimage: a numpy array with the sub-image to add.</span>
<span class="sd">        :param x: the location of the upper left point of the sub-image within</span>
<span class="sd">            the output image.</span>
<span class="sd">        :param y: the location of the upper left point of the sub-image within</span>
<span class="sd">            the output image.</span>
<span class="sd">        :param width: the output image size.</span>
<span class="sd">        :param height: the output image size.</span>
<span class="sd">        :param tiled: true to generate a tiled output image.</span>
<span class="sd">        :param tile: the original tile record with the current scale, etc.</span>
<span class="sd">        :returns: the output image record.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">tiled</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_addRegionTileToTiled</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">subimage</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">tile</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">image</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">image</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">subimage</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
                    <span class="n">dtype</span><span class="o">=</span><span class="n">subimage</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">MemoryError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">TileSourceError</span><span class="p">(</span>
                    <span class="s1">&#39;Insufficient memory to get region of </span><span class="si">%d</span><span class="s1"> x </span><span class="si">%d</span><span class="s1"> pixels.&#39;</span> <span class="o">%</span> <span class="p">(</span>
                        <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">subimage</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
            <span class="n">newimage</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">subimage</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
            <span class="n">newimage</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="o">=</span> <span class="n">image</span>
            <span class="n">image</span> <span class="o">=</span> <span class="n">newimage</span>
        <span class="n">image</span><span class="p">[</span><span class="n">y</span><span class="p">:</span><span class="n">y</span> <span class="o">+</span> <span class="n">subimage</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">:</span><span class="n">x</span> <span class="o">+</span> <span class="n">subimage</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
              <span class="p">:</span><span class="n">subimage</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="o">=</span> <span class="n">subimage</span>
        <span class="k">return</span> <span class="n">image</span>

    <span class="k">def</span> <span class="nf">_vipsAddAlphaBand</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vimg</span><span class="p">,</span> <span class="o">*</span><span class="n">otherImages</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add an alpha band to a vips image.  The alpha value is either 1, 255,</span>
<span class="sd">        or 65535 depending on the max value in the image and any other images</span>
<span class="sd">        passed for reference.</span>

<span class="sd">        :param vimg: the image to modify.</span>
<span class="sd">        :param otherImages: a list of other images to use for determining the</span>
<span class="sd">            alpha value.</span>
<span class="sd">        :returns: the original image with an alpha band.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">maxValue</span> <span class="o">=</span> <span class="n">vimg</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">img</span> <span class="ow">in</span> <span class="n">otherImages</span><span class="p">:</span>
            <span class="n">maxValue</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">maxValue</span><span class="p">,</span> <span class="n">img</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">maxValue</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">maxValue</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">**</span><span class="mi">9</span><span class="p">:</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="mi">255</span>
        <span class="k">elif</span> <span class="n">maxValue</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">8</span> <span class="ow">and</span> <span class="n">maxValue</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">**</span><span class="mi">17</span><span class="p">:</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="mi">65535</span>
        <span class="k">return</span> <span class="n">vimg</span><span class="o">.</span><span class="n">bandjoin</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_addRegionTileToTiled</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">subimage</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">tile</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a subtile to a vips image.</span>

<span class="sd">        :param image: an object with information on the output.</span>
<span class="sd">        :param subimage: a numpy array with the sub-image to add.</span>
<span class="sd">        :param x: the location of the upper left point of the sub-image within</span>
<span class="sd">            the output image.</span>
<span class="sd">        :param y: the location of the upper left point of the sub-image within</span>
<span class="sd">            the output image.</span>
<span class="sd">        :param width: the output image size.</span>
<span class="sd">        :param height: the output image size.</span>
<span class="sd">        :param tile: the original tile record with the current scale, etc.</span>
<span class="sd">        :returns: the output object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">pyvips</span>

        <span class="k">if</span> <span class="n">subimage</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">char</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dtypeToGValue</span><span class="p">:</span>
            <span class="n">subimage</span> <span class="o">=</span> <span class="n">subimage</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">)</span>
        <span class="n">vimgMem</span> <span class="o">=</span> <span class="n">pyvips</span><span class="o">.</span><span class="n">Image</span><span class="o">.</span><span class="n">new_from_memory</span><span class="p">(</span>
            <span class="n">numpy</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">subimage</span><span class="p">)</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
            <span class="n">subimage</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">subimage</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">subimage</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
            <span class="n">dtypeToGValue</span><span class="p">[</span><span class="n">subimage</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">char</span><span class="p">])</span>
        <span class="n">vimg</span> <span class="o">=</span> <span class="n">pyvips</span><span class="o">.</span><span class="n">Image</span><span class="o">.</span><span class="n">new_temp_file</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">.v&#39;</span><span class="p">)</span>
        <span class="n">vimgMem</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">vimg</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">image</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">image</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;width&#39;</span><span class="p">:</span> <span class="n">width</span><span class="p">,</span>
                <span class="s1">&#39;height&#39;</span><span class="p">:</span> <span class="n">height</span><span class="p">,</span>
                <span class="s1">&#39;mm_x&#39;</span><span class="p">:</span> <span class="n">tile</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;mm_x&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="n">tile</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;mm_y&#39;</span><span class="p">:</span> <span class="n">tile</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;mm_y&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="n">tile</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;magnification&#39;</span><span class="p">:</span> <span class="n">tile</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;magnification&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="n">tile</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;channels&#39;</span><span class="p">:</span> <span class="n">subimage</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                <span class="s1">&#39;strips&#39;</span><span class="p">:</span> <span class="p">{},</span>
            <span class="p">}</span>
        <span class="k">if</span> <span class="n">y</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">image</span><span class="p">[</span><span class="s1">&#39;strips&#39;</span><span class="p">]:</span>
            <span class="n">image</span><span class="p">[</span><span class="s1">&#39;strips&#39;</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">vimg</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">image</span>
        <span class="k">if</span> <span class="n">image</span><span class="p">[</span><span class="s1">&#39;strips&#39;</span><span class="p">][</span><span class="n">y</span><span class="p">]</span><span class="o">.</span><span class="n">bands</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">vimg</span><span class="o">.</span><span class="n">bands</span><span class="p">:</span>
            <span class="n">image</span><span class="p">[</span><span class="s1">&#39;strips&#39;</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vipsAddAlphaBand</span><span class="p">(</span><span class="n">image</span><span class="p">[</span><span class="s1">&#39;strips&#39;</span><span class="p">][</span><span class="n">y</span><span class="p">],</span> <span class="n">vimg</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">vimg</span><span class="o">.</span><span class="n">bands</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">image</span><span class="p">[</span><span class="s1">&#39;strips&#39;</span><span class="p">][</span><span class="n">y</span><span class="p">]</span><span class="o">.</span><span class="n">bands</span><span class="p">:</span>
            <span class="n">vimg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vipsAddAlphaBand</span><span class="p">(</span><span class="n">vimg</span><span class="p">,</span> <span class="n">image</span><span class="p">[</span><span class="s1">&#39;strips&#39;</span><span class="p">][</span><span class="n">y</span><span class="p">])</span>
        <span class="n">image</span><span class="p">[</span><span class="s1">&#39;strips&#39;</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">image</span><span class="p">[</span><span class="s1">&#39;strips&#39;</span><span class="p">][</span><span class="n">y</span><span class="p">]</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">vimg</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">expand</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">image</span>

    <span class="k">def</span> <span class="nf">_encodeTiledImage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">outWidth</span><span class="p">,</span> <span class="n">outHeight</span><span class="p">,</span> <span class="n">iterInfo</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given an image record of a set of vips image strips, generate a tiled</span>
<span class="sd">        tiff file at the specified output size.</span>

<span class="sd">        :param image: a record with partial vips images and the current output</span>
<span class="sd">            size.</span>
<span class="sd">        :param outWidth: the output size after scaling and before any</span>
<span class="sd">            letterboxing.</span>
<span class="sd">        :param outHeight: the output size after scaling and before any</span>
<span class="sd">            letterboxing.</span>
<span class="sd">        :param iterInfo: information about the region based on the tile</span>
<span class="sd">            iterator.</span>

<span class="sd">        Additional parameters are available.</span>

<span class="sd">        :param fill: a color to use in letterboxing.</span>
<span class="sd">        :param maxWidth: the output size if letterboxing is applied.</span>
<span class="sd">        :param maxHeight: the output size if letterboxing is applied.</span>
<span class="sd">        :param compression: the internal compression format.  This can handle</span>
<span class="sd">            a variety of options similar to the converter utility.</span>
<span class="sd">        :returns: a pathlib.Path of the output file and the output mime type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">vimg</span> <span class="o">=</span> <span class="n">image</span><span class="p">[</span><span class="s1">&#39;strips&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">image</span><span class="p">[</span><span class="s1">&#39;strips&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="k">if</span> <span class="n">image</span><span class="p">[</span><span class="s1">&#39;strips&#39;</span><span class="p">][</span><span class="n">y</span><span class="p">]</span><span class="o">.</span><span class="n">bands</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">vimg</span><span class="o">.</span><span class="n">bands</span><span class="p">:</span>
                <span class="n">image</span><span class="p">[</span><span class="s1">&#39;strips&#39;</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vipsAddAlphaBand</span><span class="p">(</span><span class="n">image</span><span class="p">[</span><span class="s1">&#39;strips&#39;</span><span class="p">][</span><span class="n">y</span><span class="p">],</span> <span class="n">vimg</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">vimg</span><span class="o">.</span><span class="n">bands</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">image</span><span class="p">[</span><span class="s1">&#39;strips&#39;</span><span class="p">][</span><span class="n">y</span><span class="p">]</span><span class="o">.</span><span class="n">bands</span><span class="p">:</span>
                <span class="n">vimg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vipsAddAlphaBand</span><span class="p">(</span><span class="n">vimg</span><span class="p">,</span> <span class="n">image</span><span class="p">[</span><span class="s1">&#39;strips&#39;</span><span class="p">][</span><span class="n">y</span><span class="p">])</span>
            <span class="n">vimg</span> <span class="o">=</span> <span class="n">vimg</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">image</span><span class="p">[</span><span class="s1">&#39;strips&#39;</span><span class="p">][</span><span class="n">y</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">expand</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">outWidth</span> <span class="o">!=</span> <span class="n">image</span><span class="p">[</span><span class="s1">&#39;width&#39;</span><span class="p">]</span> <span class="ow">or</span> <span class="n">outHeight</span> <span class="o">!=</span> <span class="n">image</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">]:</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="n">outWidth</span> <span class="o">/</span> <span class="n">image</span><span class="p">[</span><span class="s1">&#39;width&#39;</span><span class="p">]</span>
            <span class="n">vimg</span> <span class="o">=</span> <span class="n">vimg</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">outWidth</span> <span class="o">/</span> <span class="n">image</span><span class="p">[</span><span class="s1">&#39;width&#39;</span><span class="p">],</span> <span class="n">vscale</span><span class="o">=</span><span class="n">outHeight</span> <span class="o">/</span> <span class="n">image</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">])</span>
            <span class="n">image</span><span class="p">[</span><span class="s1">&#39;width&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">outWidth</span>
            <span class="n">image</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">outHeight</span>
            <span class="n">image</span><span class="p">[</span><span class="s1">&#39;mm_x&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">image</span><span class="p">[</span><span class="s1">&#39;mm_x&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">scale</span> <span class="k">if</span> <span class="n">image</span><span class="p">[</span><span class="s1">&#39;mm_x&#39;</span><span class="p">]</span> <span class="k">else</span> <span class="n">image</span><span class="p">[</span><span class="s1">&#39;mm_x&#39;</span><span class="p">]</span>
            <span class="n">image</span><span class="p">[</span><span class="s1">&#39;mm_y&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">image</span><span class="p">[</span><span class="s1">&#39;mm_y&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">scale</span> <span class="k">if</span> <span class="n">image</span><span class="p">[</span><span class="s1">&#39;mm_y&#39;</span><span class="p">]</span> <span class="k">else</span> <span class="n">image</span><span class="p">[</span><span class="s1">&#39;mm_y&#39;</span><span class="p">]</span>
            <span class="n">image</span><span class="p">[</span><span class="s1">&#39;magnification&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">image</span><span class="p">[</span><span class="s1">&#39;magnification&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">scale</span>
                <span class="k">if</span> <span class="n">image</span><span class="p">[</span><span class="s1">&#39;magnification&#39;</span><span class="p">]</span> <span class="k">else</span> <span class="n">image</span><span class="p">[</span><span class="s1">&#39;magnification&#39;</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_encodeTiledImageFromVips</span><span class="p">(</span><span class="n">vimg</span><span class="p">,</span> <span class="n">iterInfo</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_encodeTiledImageFromVips</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vimg</span><span class="p">,</span> <span class="n">iterInfo</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save a vips image as a tiled tiff.</span>

<span class="sd">        :param vimg: a vips image.</span>
<span class="sd">        :param iterInfo: information about the region based on the tile</span>
<span class="sd">            iterator.</span>
<span class="sd">        :param image: a record with partial vips images and the current output</span>
<span class="sd">            size.</span>

<span class="sd">        Additional parameters are available.</span>

<span class="sd">        :param compression: the internal compression format.  This can handle</span>
<span class="sd">            a variety of options similar to the converter utility.</span>
<span class="sd">        :returns: a pathlib.Path of the output file and the output mime type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">pyvips</span>

        <span class="n">convertParams</span> <span class="o">=</span> <span class="n">_vipsParameters</span><span class="p">(</span><span class="n">defaultCompression</span><span class="o">=</span><span class="s1">&#39;lzw&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">vimg</span> <span class="o">=</span> <span class="n">_vipsCast</span><span class="p">(</span><span class="n">vimg</span><span class="p">,</span> <span class="n">convertParams</span><span class="p">[</span><span class="s1">&#39;compression&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;webp&#39;</span><span class="p">,</span> <span class="s1">&#39;jpeg&#39;</span><span class="p">})</span>
        <span class="n">maxWidth</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;output&#39;</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;maxWidth&#39;</span><span class="p">)</span>
        <span class="n">maxHeight</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;output&#39;</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;maxHeight&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;fill&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">str</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;fill&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">!=</span> <span class="s1">&#39;none&#39;</span> <span class="ow">and</span>
                <span class="n">maxWidth</span> <span class="ow">and</span> <span class="n">maxHeight</span> <span class="ow">and</span>
                <span class="p">(</span><span class="n">maxWidth</span> <span class="o">&gt;</span> <span class="n">image</span><span class="p">[</span><span class="s1">&#39;width&#39;</span><span class="p">]</span> <span class="ow">or</span> <span class="n">maxHeight</span> <span class="o">&gt;</span> <span class="n">image</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">])):</span>
            <span class="n">corner</span><span class="p">,</span> <span class="n">fill</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;fill&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">fill</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;corner:&#39;</span><span class="p">):</span>
                <span class="n">corner</span><span class="p">,</span> <span class="n">fill</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">fill</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">color</span> <span class="o">=</span> <span class="n">PIL</span><span class="o">.</span><span class="n">ImageColor</span><span class="o">.</span><span class="n">getcolor</span><span class="p">(</span>
                <span class="n">fill</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;L&#39;</span><span class="p">,</span> <span class="s1">&#39;LA&#39;</span><span class="p">,</span> <span class="s1">&#39;RGB&#39;</span><span class="p">,</span> <span class="s1">&#39;RGBA&#39;</span><span class="p">][</span><span class="n">vimg</span><span class="o">.</span><span class="n">bands</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">color</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">color</span> <span class="o">=</span> <span class="p">[</span><span class="n">color</span><span class="p">]</span>
            <span class="n">lbimage</span> <span class="o">=</span> <span class="n">pyvips</span><span class="o">.</span><span class="n">Image</span><span class="o">.</span><span class="n">black</span><span class="p">(</span><span class="n">maxWidth</span><span class="p">,</span> <span class="n">maxHeight</span><span class="p">,</span> <span class="n">bands</span><span class="o">=</span><span class="n">vimg</span><span class="o">.</span><span class="n">bands</span><span class="p">)</span>
            <span class="n">lbimage</span> <span class="o">=</span> <span class="n">lbimage</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">vimg</span><span class="o">.</span><span class="n">format</span><span class="p">)</span>
            <span class="n">lbimage</span> <span class="o">=</span> <span class="n">lbimage</span><span class="o">.</span><span class="n">draw_rect</span><span class="p">(</span>
                <span class="p">[</span><span class="n">c</span> <span class="o">*</span> <span class="p">(</span><span class="mi">257</span> <span class="k">if</span> <span class="n">vimg</span><span class="o">.</span><span class="n">format</span> <span class="o">==</span> <span class="n">pyvips</span><span class="o">.</span><span class="n">BandFormat</span><span class="o">.</span><span class="n">USHORT</span> <span class="k">else</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">color</span><span class="p">],</span>
                <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">maxWidth</span><span class="p">,</span> <span class="n">maxHeight</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">vimg</span> <span class="o">=</span> <span class="n">lbimage</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span>
                <span class="n">vimg</span><span class="p">,</span>
                <span class="p">(</span><span class="n">maxWidth</span> <span class="o">-</span> <span class="n">image</span><span class="p">[</span><span class="s1">&#39;width&#39;</span><span class="p">])</span> <span class="o">//</span> <span class="mi">2</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">corner</span> <span class="k">else</span> <span class="mi">0</span><span class="p">,</span>
                <span class="p">(</span><span class="n">maxHeight</span> <span class="o">-</span> <span class="n">image</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">])</span> <span class="o">//</span> <span class="mi">2</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">corner</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">image</span><span class="p">[</span><span class="s1">&#39;mm_x&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">image</span><span class="p">[</span><span class="s1">&#39;mm_y&#39;</span><span class="p">]:</span>
            <span class="n">vimg</span> <span class="o">=</span> <span class="n">vimg</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">xres</span><span class="o">=</span><span class="mi">1</span> <span class="o">/</span> <span class="n">image</span><span class="p">[</span><span class="s1">&#39;mm_x&#39;</span><span class="p">],</span> <span class="n">yres</span><span class="o">=</span><span class="mi">1</span> <span class="o">/</span> <span class="n">image</span><span class="p">[</span><span class="s1">&#39;mm_y&#39;</span><span class="p">])</span>
        <span class="n">fd</span><span class="p">,</span> <span class="n">outputPath</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">mkstemp</span><span class="p">(</span><span class="s1">&#39;.tiff&#39;</span><span class="p">,</span> <span class="s1">&#39;tiledRegion_&#39;</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">vimg</span><span class="o">.</span><span class="n">write_to_file</span><span class="p">(</span><span class="n">outputPath</span><span class="p">,</span> <span class="o">**</span><span class="n">convertParams</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">outputPath</span><span class="p">),</span> <span class="n">TileOutputMimeTypes</span><span class="p">[</span><span class="s1">&#39;TILED&#39;</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">outputPath</span><span class="p">)</span><span class="o">.</span><span class="n">unlink</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">raise</span> <span class="n">exc</span>

<div class="viewcode-block" id="TileSource.tileFrames"><a class="viewcode-back" href="../../../large_image/large_image.tilesource.html#large_image.tilesource.base.TileSource.tileFrames">[docs]</a>    <span class="k">def</span> <span class="nf">tileFrames</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="p">(</span><span class="n">TILE_FORMAT_IMAGE</span><span class="p">,</span> <span class="p">),</span> <span class="n">frameList</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">framesAcross</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given the parameters for getRegion, plus a list of frames and the</span>
<span class="sd">        number of frames across, make a larger image composed of a region from</span>
<span class="sd">        each listed frame composited together.</span>

<span class="sd">        :param format: the desired format or a tuple of allowed formats.</span>
<span class="sd">            Formats are members of (TILE_FORMAT_PIL, TILE_FORMAT_NUMPY,</span>
<span class="sd">            TILE_FORMAT_IMAGE).  If TILE_FORMAT_IMAGE, encoding may be</span>
<span class="sd">            specified.</span>
<span class="sd">        :param frameList: None for all frames, or a list of 0-based integers.</span>
<span class="sd">        :param framesAcross: the number of frames across the final image.  If</span>
<span class="sd">            unspecified, this is the ceiling of sqrt(number of frames in frame</span>
<span class="sd">            list).</span>
<span class="sd">        :param kwargs: optional arguments.  Some options are region, output,</span>
<span class="sd">            encoding, jpegQuality, jpegSubsampling, tiffCompression, fill.  See</span>
<span class="sd">            tileIterator.</span>
<span class="sd">        :returns: regionData, formatOrRegionMime: the image data and either the</span>
<span class="sd">            mime type, if the format is TILE_FORMAT_IMAGE, or the format.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lastlog</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;tile_position&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;frame&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">numFrames</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getMetadata</span><span class="p">()</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;frames&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">frameList</span><span class="p">:</span>
            <span class="n">frameList</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">frameList</span> <span class="k">if</span> <span class="n">f</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">f</span> <span class="o">&lt;</span> <span class="n">numFrames</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">frameList</span><span class="p">:</span>
            <span class="n">frameList</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">numFrames</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">frameList</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getRegion</span><span class="p">(</span><span class="nb">format</span><span class="o">=</span><span class="nb">format</span><span class="p">,</span> <span class="n">frame</span><span class="o">=</span><span class="n">frameList</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">framesAcross</span><span class="p">:</span>
            <span class="n">framesAcross</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">frameList</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span><span class="p">))</span>
        <span class="n">framesAcross</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">frameList</span><span class="p">),</span> <span class="n">framesAcross</span><span class="p">)</span>
        <span class="n">framesHigh</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">frameList</span><span class="p">)</span> <span class="o">/</span> <span class="n">framesAcross</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">format</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">set</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
            <span class="nb">format</span> <span class="o">=</span> <span class="p">(</span><span class="nb">format</span><span class="p">,</span> <span class="p">)</span>
        <span class="n">tiled</span> <span class="o">=</span> <span class="n">TILE_FORMAT_IMAGE</span> <span class="ow">in</span> <span class="nb">format</span> <span class="ow">and</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;encoding&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;TILED&#39;</span>
        <span class="n">iterInfo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tileIteratorInfo</span><span class="p">(</span><span class="n">frame</span><span class="o">=</span><span class="n">frameList</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">iterInfo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">image</span> <span class="o">=</span> <span class="n">PIL</span><span class="o">.</span><span class="n">Image</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s1">&#39;RGB&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">_encodeImage</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="nb">format</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">frameWidth</span> <span class="o">=</span> <span class="n">iterInfo</span><span class="p">[</span><span class="s1">&#39;output&#39;</span><span class="p">][</span><span class="s1">&#39;width&#39;</span><span class="p">]</span>
        <span class="n">frameHeight</span> <span class="o">=</span> <span class="n">iterInfo</span><span class="p">[</span><span class="s1">&#39;output&#39;</span><span class="p">][</span><span class="s1">&#39;height&#39;</span><span class="p">]</span>
        <span class="n">maxWidth</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;output&#39;</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;maxWidth&#39;</span><span class="p">)</span>
        <span class="n">maxHeight</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;output&#39;</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;maxHeight&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;fill&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">maxWidth</span> <span class="ow">and</span> <span class="n">maxHeight</span><span class="p">:</span>
            <span class="n">frameWidth</span><span class="p">,</span> <span class="n">frameHeight</span> <span class="o">=</span> <span class="n">maxWidth</span><span class="p">,</span> <span class="n">maxHeight</span>
        <span class="n">outWidth</span> <span class="o">=</span> <span class="n">frameWidth</span> <span class="o">*</span> <span class="n">framesAcross</span>
        <span class="n">outHeight</span> <span class="o">=</span> <span class="n">frameHeight</span> <span class="o">*</span> <span class="n">framesHigh</span>
        <span class="n">tile</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tileIterator</span><span class="p">(</span><span class="n">iterInfo</span><span class="p">))</span>
        <span class="n">image</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">frame</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">frameList</span><span class="p">):</span>
            <span class="n">subimage</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getRegion</span><span class="p">(</span><span class="nb">format</span><span class="o">=</span><span class="n">TILE_FORMAT_NUMPY</span><span class="p">,</span> <span class="n">frame</span><span class="o">=</span><span class="n">frame</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">offsetX</span> <span class="o">=</span> <span class="p">(</span><span class="n">idx</span> <span class="o">%</span> <span class="n">framesAcross</span><span class="p">)</span> <span class="o">*</span> <span class="n">frameWidth</span>
            <span class="n">offsetY</span> <span class="o">=</span> <span class="p">(</span><span class="n">idx</span> <span class="o">//</span> <span class="n">framesAcross</span><span class="p">)</span> <span class="o">*</span> <span class="n">frameHeight</span>
            <span class="k">if</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">lastlog</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="s1">&#39;Tiling frame </span><span class="si">%d</span><span class="s1"> (</span><span class="si">%d</span><span class="s1">/</span><span class="si">%d</span><span class="s1">), offset </span><span class="si">%d</span><span class="s1">x</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">,</span>
                    <span class="n">frame</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">frameList</span><span class="p">),</span> <span class="n">offsetX</span><span class="p">,</span> <span class="n">offsetY</span><span class="p">)</span>
                <span class="n">lastlog</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                    <span class="s1">&#39;Tiling frame </span><span class="si">%d</span><span class="s1"> (</span><span class="si">%d</span><span class="s1">/</span><span class="si">%d</span><span class="s1">), offset </span><span class="si">%d</span><span class="s1">x</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">,</span>
                    <span class="n">frame</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">frameList</span><span class="p">),</span> <span class="n">offsetX</span><span class="p">,</span> <span class="n">offsetY</span><span class="p">)</span>
            <span class="n">image</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_addRegionTileToImage</span><span class="p">(</span>
                <span class="n">image</span><span class="p">,</span> <span class="n">subimage</span><span class="p">,</span> <span class="n">offsetX</span><span class="p">,</span> <span class="n">offsetY</span><span class="p">,</span> <span class="n">outWidth</span><span class="p">,</span> <span class="n">outHeight</span><span class="p">,</span> <span class="n">tiled</span><span class="p">,</span>
                <span class="n">tile</span><span class="o">=</span><span class="n">tile</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">tiled</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_encodeTiledImage</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">outWidth</span><span class="p">,</span> <span class="n">outHeight</span><span class="p">,</span> <span class="n">iterInfo</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_encodeImage</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="nb">format</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="TileSource.getRegionAtAnotherScale"><a class="viewcode-back" href="../../../large_image/large_image.tilesource.html#large_image.tilesource.base.TileSource.getRegionAtAnotherScale">[docs]</a>    <span class="k">def</span> <span class="nf">getRegionAtAnotherScale</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sourceRegion</span><span class="p">,</span> <span class="n">sourceScale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                <span class="n">targetScale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">targetUnits</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This takes the same parameters and returns the same results as</span>
<span class="sd">        getRegion, except instead of region and scale, it takes sourceRegion,</span>
<span class="sd">        sourceScale, targetScale, and targetUnits.  These parameters are the</span>
<span class="sd">        same as convertRegionScale.  See those two functions for parameter</span>
<span class="sd">        definitions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;region&#39;</span><span class="p">,</span> <span class="s1">&#39;scale&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;getRegionAtAnotherScale() got an unexpected &#39;</span>
                                <span class="s1">&#39;keyword argument of &quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span> <span class="n">key</span><span class="p">)</span>
        <span class="n">region</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convertRegionScale</span><span class="p">(</span><span class="n">sourceRegion</span><span class="p">,</span> <span class="n">sourceScale</span><span class="p">,</span>
                                         <span class="n">targetScale</span><span class="p">,</span> <span class="n">targetUnits</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getRegion</span><span class="p">(</span><span class="n">region</span><span class="o">=</span><span class="n">region</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">targetScale</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="TileSource.getPointAtAnotherScale"><a class="viewcode-back" href="../../../large_image/large_image.tilesource.html#large_image.tilesource.base.TileSource.getPointAtAnotherScale">[docs]</a>    <span class="k">def</span> <span class="nf">getPointAtAnotherScale</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">sourceScale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sourceUnits</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                               <span class="n">targetScale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">targetUnits</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a point as a (x, y) tuple, convert it from one scale to another.</span>
<span class="sd">        The sourceScale, sourceUnits, targetScale, and targetUnits parameters</span>
<span class="sd">        are the same as convertRegionScale, where sourceUnits are the units</span>
<span class="sd">        used with sourceScale.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sourceRegion</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;units&#39;</span><span class="p">:</span> <span class="s1">&#39;base_pixels&#39;</span> <span class="k">if</span> <span class="n">sourceUnits</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">sourceUnits</span><span class="p">,</span>
            <span class="s1">&#39;left&#39;</span><span class="p">:</span> <span class="n">point</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="s1">&#39;top&#39;</span><span class="p">:</span> <span class="n">point</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="s1">&#39;right&#39;</span><span class="p">:</span> <span class="n">point</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="s1">&#39;bottom&#39;</span><span class="p">:</span> <span class="n">point</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
        <span class="p">}</span>
        <span class="n">region</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convertRegionScale</span><span class="p">(</span>
            <span class="n">sourceRegion</span><span class="p">,</span> <span class="n">sourceScale</span><span class="p">,</span> <span class="n">targetScale</span><span class="p">,</span> <span class="n">targetUnits</span><span class="p">,</span>
            <span class="n">cropToImage</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">region</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">],</span> <span class="n">region</span><span class="p">[</span><span class="s1">&#39;top&#39;</span><span class="p">])</span></div>

<div class="viewcode-block" id="TileSource.getNativeMagnification"><a class="viewcode-back" href="../../../large_image/large_image.tilesource.html#large_image.tilesource.base.TileSource.getNativeMagnification">[docs]</a>    <span class="k">def</span> <span class="nf">getNativeMagnification</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the magnification for the highest-resolution level.</span>

<span class="sd">        :return: magnification, width of a pixel in mm, height of a pixel in mm.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;magnification&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s1">&#39;mm_x&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s1">&#39;mm_y&#39;</span><span class="p">:</span> <span class="kc">None</span>
        <span class="p">}</span></div>

<div class="viewcode-block" id="TileSource.getMagnificationForLevel"><a class="viewcode-back" href="../../../large_image/large_image.tilesource.html#large_image.tilesource.base.TileSource.getMagnificationForLevel">[docs]</a>    <span class="k">def</span> <span class="nf">getMagnificationForLevel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the magnification at a particular level.</span>

<span class="sd">        :param level: None to use the maximum level, otherwise the level to get</span>
<span class="sd">            the magnification factor of.</span>
<span class="sd">        :return: magnification, width of a pixel in mm, height of a pixel in mm.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNativeMagnification</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">levels</span> <span class="ow">and</span> <span class="n">level</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">levels</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">mag</span><span class="p">[</span><span class="s1">&#39;scale&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">**</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">levels</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">level</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">mag</span><span class="p">[</span><span class="s1">&#39;magnification&#39;</span><span class="p">]:</span>
                <span class="n">mag</span><span class="p">[</span><span class="s1">&#39;magnification&#39;</span><span class="p">]</span> <span class="o">/=</span> <span class="n">mag</span><span class="p">[</span><span class="s1">&#39;scale&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">mag</span><span class="p">[</span><span class="s1">&#39;mm_x&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">mag</span><span class="p">[</span><span class="s1">&#39;mm_y&#39;</span><span class="p">]:</span>
                <span class="n">mag</span><span class="p">[</span><span class="s1">&#39;mm_x&#39;</span><span class="p">]</span> <span class="o">*=</span> <span class="n">mag</span><span class="p">[</span><span class="s1">&#39;scale&#39;</span><span class="p">]</span>
                <span class="n">mag</span><span class="p">[</span><span class="s1">&#39;mm_y&#39;</span><span class="p">]</span> <span class="o">*=</span> <span class="n">mag</span><span class="p">[</span><span class="s1">&#39;scale&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">:</span>
            <span class="n">mag</span><span class="p">[</span><span class="s1">&#39;level&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">level</span> <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">levels</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">mag</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;level&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">levels</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">mag</span><span class="p">[</span><span class="s1">&#39;scale&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="k">return</span> <span class="n">mag</span></div>

<div class="viewcode-block" id="TileSource.getLevelForMagnification"><a class="viewcode-back" href="../../../large_image/large_image.tilesource.html#large_image.tilesource.base.TileSource.getLevelForMagnification">[docs]</a>    <span class="k">def</span> <span class="nf">getLevelForMagnification</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">magnification</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                 <span class="n">mm_x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mm_y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rounding</span><span class="o">=</span><span class="s1">&#39;round&#39;</span><span class="p">,</span>
                                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the level for a specific magnification or pixel size.  If the</span>
<span class="sd">        magnification is unknown or no level is sufficient resolution, and an</span>
<span class="sd">        exact match is not requested, the highest level will be returned.</span>

<span class="sd">        If none of magnification, mm_x, and mm_y are specified, the maximum</span>
<span class="sd">        level is returned.  If more than one of these values is given, an</span>
<span class="sd">        average of those given will be used (exact will require all of them to</span>
<span class="sd">        match).</span>

<span class="sd">        :param magnification: the magnification ratio.</span>
<span class="sd">        :param exact: if True, only a level that matches exactly will be</span>
<span class="sd">            returned.</span>
<span class="sd">        :param mm_x: the horizontal size of a pixel in millimeters.</span>
<span class="sd">        :param mm_y: the vertical size of a pixel in millimeters.</span>
<span class="sd">        :param rounding: if False, a fractional level may be returned.  If</span>
<span class="sd">            &#39;ceil&#39; or &#39;round&#39;, that function is used to convert the level to an</span>
<span class="sd">            integer (the exact flag still applies).  If None, the level is not</span>
<span class="sd">            cropped to the actual image&#39;s level range.</span>
<span class="sd">        :returns: the selected level or None for no match.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getMagnificationForLevel</span><span class="p">()</span>
        <span class="n">ratios</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">magnification</span> <span class="ow">and</span> <span class="n">mag</span><span class="p">[</span><span class="s1">&#39;magnification&#39;</span><span class="p">]:</span>
            <span class="n">ratios</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">magnification</span><span class="p">)</span> <span class="o">/</span> <span class="n">mag</span><span class="p">[</span><span class="s1">&#39;magnification&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">mm_x</span> <span class="ow">and</span> <span class="n">mag</span><span class="p">[</span><span class="s1">&#39;mm_x&#39;</span><span class="p">]:</span>
            <span class="n">ratios</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mag</span><span class="p">[</span><span class="s1">&#39;mm_x&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">mm_x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mm_y</span> <span class="ow">and</span> <span class="n">mag</span><span class="p">[</span><span class="s1">&#39;mm_y&#39;</span><span class="p">]:</span>
            <span class="n">ratios</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mag</span><span class="p">[</span><span class="s1">&#39;mm_y&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">mm_y</span><span class="p">)</span>
        <span class="n">ratios</span> <span class="o">=</span> <span class="p">[</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">ratio</span><span class="p">)</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">ratio</span> <span class="ow">in</span> <span class="n">ratios</span><span class="p">]</span>
        <span class="c1"># Perform some slight rounding to handle numerical precision issues</span>
        <span class="n">ratios</span> <span class="o">=</span> <span class="p">[</span><span class="nb">round</span><span class="p">(</span><span class="n">ratio</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="k">for</span> <span class="n">ratio</span> <span class="ow">in</span> <span class="n">ratios</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">ratios</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">mag</span><span class="p">[</span><span class="s1">&#39;level&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">exact</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">ratio</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ratio</span> <span class="ow">or</span> <span class="n">ratio</span> <span class="o">!=</span> <span class="n">ratios</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                   <span class="k">for</span> <span class="n">ratio</span> <span class="ow">in</span> <span class="n">ratios</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">None</span>
        <span class="n">ratio</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">ratios</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">ratios</span><span class="p">),</span> <span class="mi">4</span><span class="p">)</span>
        <span class="n">level</span> <span class="o">=</span> <span class="n">mag</span><span class="p">[</span><span class="s1">&#39;level&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">ratio</span>
        <span class="k">if</span> <span class="n">rounding</span><span class="p">:</span>
            <span class="n">level</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">level</span><span class="p">)</span> <span class="k">if</span> <span class="n">rounding</span> <span class="o">==</span> <span class="s1">&#39;ceil&#39;</span> <span class="k">else</span>
                        <span class="nb">round</span><span class="p">(</span><span class="n">level</span><span class="p">))</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">exact</span> <span class="ow">and</span> <span class="p">(</span><span class="n">level</span> <span class="o">&gt;</span> <span class="n">mag</span><span class="p">[</span><span class="s1">&#39;level&#39;</span><span class="p">]</span> <span class="ow">or</span> <span class="n">level</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span>
                <span class="p">(</span><span class="n">rounding</span> <span class="o">==</span> <span class="s1">&#39;ceil&#39;</span> <span class="ow">and</span> <span class="n">level</span> <span class="o">&gt;</span> <span class="n">mag</span><span class="p">[</span><span class="s1">&#39;level&#39;</span><span class="p">])):</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">rounding</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">level</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">mag</span><span class="p">[</span><span class="s1">&#39;level&#39;</span><span class="p">],</span> <span class="n">level</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">level</span></div>

<div class="viewcode-block" id="TileSource.tileIterator"><a class="viewcode-back" href="../../../large_image/large_image.tilesource.html#large_image.tilesource.base.TileSource.tileIterator">[docs]</a>    <span class="k">def</span> <span class="nf">tileIterator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="p">(</span><span class="n">TILE_FORMAT_NUMPY</span><span class="p">,</span> <span class="p">),</span> <span class="n">resample</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                     <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate on all tiles in the specified region at the specified scale.</span>
<span class="sd">        Each tile is returned as part of a dictionary that includes</span>

<span class="sd">            :x, y: (left, top) coordinates in current magnification pixels</span>
<span class="sd">            :width, height: size of current tile in current magnification pixels</span>
<span class="sd">            :tile: cropped tile image</span>
<span class="sd">            :format: format of the tile</span>
<span class="sd">            :level: level of the current tile</span>
<span class="sd">            :level_x, level_y: the tile reference number within the level.</span>
<span class="sd">                Tiles are numbered (0, 0), (1, 0), (2, 0), etc.  The 0th tile</span>
<span class="sd">                yielded may not be (0, 0) if a region is specified.</span>
<span class="sd">            :tile_position: a dictionary of the tile position within the</span>
<span class="sd">                iterator, containing:</span>

<span class="sd">                :level_x, level_y: the tile reference number within the level.</span>
<span class="sd">                :region_x, region_y: 0, 0 is the first tile in the full</span>
<span class="sd">                    iteration (when not restricting the iteration to a single</span>
<span class="sd">                    tile).</span>
<span class="sd">                :position: a 0-based value for the tile within the full</span>
<span class="sd">                    iteration.</span>

<span class="sd">            :iterator_range: a dictionary of the output range of the iterator:</span>

<span class="sd">                :level_x_min, level_x_max: the tiles that are be included</span>
<span class="sd">                    during the full iteration: [layer_x_min, layer_x_max).</span>
<span class="sd">                :level_y_min, level_y_max: the tiles that are be included</span>
<span class="sd">                    during the full iteration: [layer_y_min, layer_y_max).</span>
<span class="sd">                :region_x_max, region_y_max: the number of tiles included during</span>
<span class="sd">                    the full iteration.   This is layer_x_max - layer_x_min,</span>
<span class="sd">                    layer_y_max - layer_y_min.</span>
<span class="sd">                :position: the total number of tiles included in the full</span>
<span class="sd">                    iteration.  This is region_x_max * region_y_max.</span>

<span class="sd">            :magnification: magnification of the current tile</span>
<span class="sd">            :mm_x, mm_y: size of the current tile pixel in millimeters.</span>
<span class="sd">            :gx, gy: (left, top) coordinates in maximum-resolution pixels</span>
<span class="sd">            :gwidth, gheight: size of of the current tile in maximum-resolution</span>
<span class="sd">                pixels.</span>
<span class="sd">            :tile_overlap: the amount of overlap with neighboring tiles (left,</span>
<span class="sd">                top, right, and bottom).  Overlap never extends outside of the</span>
<span class="sd">                requested region.</span>

<span class="sd">        If a region that includes partial tiles is requested, those tiles are</span>
<span class="sd">        cropped appropriately.  Most images will have tiles that get cropped</span>
<span class="sd">        along the right and bottom edges in any case.  If an exact</span>
<span class="sd">        magnification or scale is requested, no tiles will be returned.</span>

<span class="sd">        :param format: the desired format or a tuple of allowed formats.</span>
<span class="sd">            Formats are members of (TILE_FORMAT_PIL, TILE_FORMAT_NUMPY,</span>
<span class="sd">            TILE_FORMAT_IMAGE).  If TILE_FORMAT_IMAGE, encoding must be</span>
<span class="sd">            specified.</span>
<span class="sd">        :param resample: If True or one of PIL.Image.NEAREST, LANCZOS,</span>
<span class="sd">            BILINEAR, or BICUBIC to resample tiles that are not the target</span>
<span class="sd">            output size.  Tiles that are resampled will have additional</span>
<span class="sd">            dictionary entries of:</span>

<span class="sd">            :scaled: the scaling factor that was applied (less than 1 is</span>
<span class="sd">                downsampled).</span>
<span class="sd">            :tile_x, tile_y: (left, top) coordinates before scaling</span>
<span class="sd">            :tile_width, tile_height: size of the current tile before</span>
<span class="sd">                scaling.</span>
<span class="sd">            :tile_magnification: magnification of the current tile before</span>
<span class="sd">                scaling.</span>
<span class="sd">            :tile_mm_x, tile_mm_y: size of a pixel in a tile in millimeters</span>
<span class="sd">                before scaling.</span>

<span class="sd">            Note that scipy.misc.imresize uses PIL internally.</span>
<span class="sd">        :param region: a dictionary of optional values which specify the part</span>
<span class="sd">            of the image to process:</span>

<span class="sd">            :left: the left edge (inclusive) of the region to process.</span>
<span class="sd">            :top: the top edge (inclusive) of the region to process.</span>
<span class="sd">            :right: the right edge (exclusive) of the region to process.</span>
<span class="sd">            :bottom: the bottom edge (exclusive) of the region to process.</span>
<span class="sd">            :width: the width of the region to process.</span>
<span class="sd">            :height: the height of the region to process.</span>
<span class="sd">            :units: either &#39;base_pixels&#39; (default), &#39;pixels&#39;, &#39;mm&#39;, or</span>
<span class="sd">                &#39;fraction&#39;.  base_pixels are in maximum resolution pixels.</span>
<span class="sd">                pixels is in the specified magnification pixels.  mm is in the</span>
<span class="sd">                specified magnification scale.  fraction is a scale of 0 to 1.</span>
<span class="sd">                pixels and mm are only available if the magnification and mm</span>
<span class="sd">                per pixel are defined for the image.</span>

<span class="sd">        :param output: a dictionary of optional values which specify the size</span>
<span class="sd">            of the output.</span>

<span class="sd">            :maxWidth: maximum width in pixels.  If either maxWidth or maxHeight</span>
<span class="sd">                is specified, magnification, mm_x, and mm_y are ignored.</span>
<span class="sd">            :maxHeight: maximum height in pixels.</span>

<span class="sd">        :param scale: a dictionary of optional values which specify the scale</span>
<span class="sd">            of the region and / or output.  This applies to region if</span>
<span class="sd">            pixels or mm are used for inits.  It applies to output if</span>
<span class="sd">            neither output maxWidth nor maxHeight is specified.</span>

<span class="sd">            :magnification: the magnification ratio.  Only used is maxWidth and</span>
<span class="sd">                maxHeight are not specified or None.</span>
<span class="sd">            :mm_x: the horizontal size of a pixel in millimeters.</span>
<span class="sd">            :mm_y: the vertical size of a pixel in millimeters.</span>
<span class="sd">            :exact: if True, only a level that matches exactly will be returned.</span>
<span class="sd">                This is only applied if magnification, mm_x, or mm_y is used.</span>

<span class="sd">        :param tile_position: if present, either a number to only yield the</span>
<span class="sd">            (tile_position)th tile [0 to (xmax - min) * (ymax - ymin)) that the</span>
<span class="sd">            iterator would yield, or a dictionary of {region_x, region_y} to</span>
<span class="sd">            yield that tile, where 0, 0 is the first tile yielded, and</span>
<span class="sd">            xmax - xmin - 1, ymax - ymin - 1 is the last tile yielded, or a</span>
<span class="sd">            dictionary of {level_x, level_y} to yield that specific tile if it</span>
<span class="sd">            is in the region.</span>
<span class="sd">        :param tile_size: if present, retile the output to the specified tile</span>
<span class="sd">            size.  If only width or only height is specified, the resultant</span>
<span class="sd">            tiles will be square.  This is a dictionary containing at least</span>
<span class="sd">            one of:</span>

<span class="sd">            :width: the desired tile width.</span>
<span class="sd">            :height: the desired tile height.</span>

<span class="sd">        :param tile_overlap: if present, retile the output adding a symmetric</span>
<span class="sd">            overlap to the tiles.  If either x or y is not specified, it</span>
<span class="sd">            defaults to zero.  The overlap does not change the tile size,</span>
<span class="sd">            only the stride of the tiles.  This is a dictionary containing:</span>

<span class="sd">            :x: the horizontal overlap in pixels.</span>
<span class="sd">            :y: the vertical overlap in pixels.</span>
<span class="sd">            :edges: if True, then the edge tiles will exclude the overlap</span>
<span class="sd">                distance.  If unset or False, the edge tiles are full size.</span>

<span class="sd">                The overlap is conceptually split between the two sides of</span>
<span class="sd">                the tile.  This is only relevant to where overlap is reported</span>
<span class="sd">                or if edges is True</span>

<span class="sd">                As an example, suppose an image that is 8 pixels across</span>
<span class="sd">                (01234567) and a tile size of 5 is requested with an overlap of</span>
<span class="sd">                4.  If the edges option is False (the default), the following</span>
<span class="sd">                tiles are returned: 01234, 12345, 23456, 34567.  Each tile</span>
<span class="sd">                reports its overlap, and the non-overlapped area of each tile</span>
<span class="sd">                is 012, 3, 4, 567.  If the edges option is True, the tiles</span>
<span class="sd">                returned are: 012, 0123, 01234, 12345, 23456, 34567, 4567, 567,</span>
<span class="sd">                with the non-overlapped area of each as 0, 1, 2, 3, 4, 5, 6, 7.</span>

<span class="sd">        :param encoding: if format includes TILE_FORMAT_IMAGE, a valid PIL</span>
<span class="sd">            encoding (typically &#39;PNG&#39;, &#39;JPEG&#39;, or &#39;TIFF&#39;) or &#39;TILED&#39; (identical</span>
<span class="sd">            to TIFF).  Must also be in the TileOutputMimeTypes map.</span>
<span class="sd">        :param jpegQuality: the quality to use when encoding a JPEG.</span>
<span class="sd">        :param jpegSubsampling: the subsampling level to use when encoding a</span>
<span class="sd">            JPEG.</span>
<span class="sd">        :param tiffCompression: the compression format when encoding a TIFF.</span>
<span class="sd">            This is usually &#39;raw&#39;, &#39;tiff_lzw&#39;, &#39;jpeg&#39;, or &#39;tiff_adobe_deflate&#39;.</span>
<span class="sd">            Some of these are aliased: &#39;none&#39;, &#39;lzw&#39;, &#39;deflate&#39;.</span>
<span class="sd">        :param kwargs: optional arguments.</span>
<span class="sd">        :yields: an iterator that returns a dictionary as listed above.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">format</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="nb">format</span> <span class="o">=</span> <span class="p">(</span><span class="nb">format</span><span class="p">,</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">TILE_FORMAT_IMAGE</span> <span class="ow">in</span> <span class="nb">format</span><span class="p">:</span>
            <span class="n">encoding</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;encoding&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">encoding</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">TileOutputMimeTypes</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid encoding &quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span> <span class="n">encoding</span><span class="p">)</span>
        <span class="n">iterFormat</span> <span class="o">=</span> <span class="nb">format</span> <span class="k">if</span> <span class="n">resample</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">else</span> <span class="p">(</span>
            <span class="n">TILE_FORMAT_PIL</span><span class="p">,</span> <span class="p">)</span>
        <span class="n">iterInfo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tileIteratorInfo</span><span class="p">(</span><span class="nb">format</span><span class="o">=</span><span class="n">iterFormat</span><span class="p">,</span> <span class="n">resample</span><span class="o">=</span><span class="n">resample</span><span class="p">,</span>
                                          <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">iterInfo</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="c1"># check if the desired scale is different from the actual scale and</span>
        <span class="c1"># resampling is needed.  Ignore small scale differences.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">resample</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span>
                <span class="nb">round</span><span class="p">(</span><span class="n">iterInfo</span><span class="p">[</span><span class="s1">&#39;requestedScale&#39;</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mf">1.0</span><span class="p">):</span>
            <span class="n">resample</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">tile</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tileIterator</span><span class="p">(</span><span class="n">iterInfo</span><span class="p">):</span>
            <span class="n">tile</span><span class="o">.</span><span class="n">setFormat</span><span class="p">(</span><span class="nb">format</span><span class="p">,</span> <span class="n">resample</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">tile</span></div>

<div class="viewcode-block" id="TileSource.tileIteratorAtAnotherScale"><a class="viewcode-back" href="../../../large_image/large_image.tilesource.html#large_image.tilesource.base.TileSource.tileIteratorAtAnotherScale">[docs]</a>    <span class="k">def</span> <span class="nf">tileIteratorAtAnotherScale</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sourceRegion</span><span class="p">,</span> <span class="n">sourceScale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                   <span class="n">targetScale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">targetUnits</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                   <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This takes the same parameters and returns the same results as</span>
<span class="sd">        tileIterator, except instead of region and scale, it takes</span>
<span class="sd">        sourceRegion, sourceScale, targetScale, and targetUnits.  These</span>
<span class="sd">        parameters are the same as convertRegionScale.  See those two functions</span>
<span class="sd">        for parameter definitions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;region&#39;</span><span class="p">,</span> <span class="s1">&#39;scale&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;getRegionAtAnotherScale() got an unexpected &#39;</span>
                                <span class="s1">&#39;keyword argument of &quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span> <span class="n">key</span><span class="p">)</span>
        <span class="n">region</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convertRegionScale</span><span class="p">(</span><span class="n">sourceRegion</span><span class="p">,</span> <span class="n">sourceScale</span><span class="p">,</span>
                                         <span class="n">targetScale</span><span class="p">,</span> <span class="n">targetUnits</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tileIterator</span><span class="p">(</span><span class="n">region</span><span class="o">=</span><span class="n">region</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">targetScale</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="TileSource.getSingleTile"><a class="viewcode-back" href="../../../large_image/large_image.tilesource.html#large_image.tilesource.base.TileSource.getSingleTile">[docs]</a>    <span class="k">def</span> <span class="nf">getSingleTile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return any single tile from an iterator.  This takes exactly the same</span>
<span class="sd">        parameters as tileIterator.  Use tile_position to get a specific tile,</span>
<span class="sd">        otherwise the first tile is returned.</span>

<span class="sd">        :return: a tile dictionary or None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tileIterator</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span></div>

<div class="viewcode-block" id="TileSource.getSingleTileAtAnotherScale"><a class="viewcode-back" href="../../../large_image/large_image.tilesource.html#large_image.tilesource.base.TileSource.getSingleTileAtAnotherScale">[docs]</a>    <span class="k">def</span> <span class="nf">getSingleTileAtAnotherScale</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return any single tile from a rescaled iterator.  This takes exactly</span>
<span class="sd">        the same parameters as tileIteratorAtAnotherScale.  Use tile_position</span>
<span class="sd">        to get a specific tile, otherwise the first tile is returned.</span>

<span class="sd">        :return: a tile dictionary or None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tileIteratorAtAnotherScale</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span></div>

<div class="viewcode-block" id="TileSource.getTileCount"><a class="viewcode-back" href="../../../large_image/large_image.tilesource.html#large_image.tilesource.base.TileSource.getTileCount">[docs]</a>    <span class="k">def</span> <span class="nf">getTileCount</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of tiles that the tileIterator will return.  See</span>
<span class="sd">        tileIterator for parameters.</span>

<span class="sd">        :return: the number of tiles that the tileIterator will yield.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tile</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tileIterator</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">tile</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">tile</span><span class="p">[</span><span class="s1">&#39;iterator_range&#39;</span><span class="p">][</span><span class="s1">&#39;position&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="TileSource.getAssociatedImagesList"><a class="viewcode-back" href="../../../large_image/large_image.tilesource.html#large_image.tilesource.base.TileSource.getAssociatedImagesList">[docs]</a>    <span class="k">def</span> <span class="nf">getAssociatedImagesList</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of associated images.</span>

<span class="sd">        :return: the list of image keys.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[]</span></div>

<div class="viewcode-block" id="TileSource.getAssociatedImage"><a class="viewcode-back" href="../../../large_image/large_image.tilesource.html#large_image.tilesource.base.TileSource.getAssociatedImage">[docs]</a>    <span class="k">def</span> <span class="nf">getAssociatedImage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">imageKey</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an associated image.</span>

<span class="sd">        :param imageKey: the key of the associated image to retrieve.</span>
<span class="sd">        :param kwargs: optional arguments.  Some options are width, height,</span>
<span class="sd">            encoding, jpegQuality, jpegSubsampling, and tiffCompression.</span>
<span class="sd">        :returns: imageData, imageMime: the image data and the mime type, or</span>
<span class="sd">            None if the associated image doesn&#39;t exist.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">image</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getAssociatedImage</span><span class="p">(</span><span class="n">imageKey</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">image</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">imageWidth</span><span class="p">,</span> <span class="n">imageHeight</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">size</span>
        <span class="n">width</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;width&#39;</span><span class="p">)</span>
        <span class="n">height</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;height&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">width</span> <span class="ow">or</span> <span class="n">height</span><span class="p">:</span>
            <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">calcScale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculateWidthHeight</span><span class="p">(</span>
                <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">imageWidth</span><span class="p">,</span> <span class="n">imageHeight</span><span class="p">)</span>
            <span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span>
                <span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">),</span>
                <span class="n">PIL</span><span class="o">.</span><span class="n">Image</span><span class="o">.</span><span class="n">BICUBIC</span> <span class="k">if</span> <span class="n">width</span> <span class="o">&gt;</span> <span class="n">imageWidth</span> <span class="k">else</span> <span class="n">PIL</span><span class="o">.</span><span class="n">Image</span><span class="o">.</span><span class="n">LANCZOS</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_encodeImage</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="TileSource.getPixel"><a class="viewcode-back" href="../../../large_image/large_image.tilesource.html#large_image.tilesource.base.TileSource.getPixel">[docs]</a>    <span class="k">def</span> <span class="nf">getPixel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">includeTileRecord</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a single pixel from the current tile source.</span>

<span class="sd">        :param includeTileRecord: if True, include the tile used for computing</span>
<span class="sd">            the pixel in the response.</span>
<span class="sd">        :param kwargs: optional arguments.  Some options are region, output,</span>
<span class="sd">            encoding, jpegQuality, jpegSubsampling, tiffCompression, fill.  See</span>
<span class="sd">            tileIterator.</span>
<span class="sd">        :returns: a dictionary with the value of the pixel for each channel on</span>
<span class="sd">            a scale of [0-255], including alpha, if available.  This may</span>
<span class="sd">            contain additional information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">regionArgs</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">regionArgs</span><span class="p">[</span><span class="s1">&#39;region&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">regionArgs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;region&#39;</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">regionArgs</span><span class="p">[</span><span class="s1">&#39;region&#39;</span><span class="p">][</span><span class="s1">&#39;width&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">regionArgs</span><span class="p">[</span><span class="s1">&#39;region&#39;</span><span class="p">][</span><span class="s1">&#39;height&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">regionArgs</span><span class="p">[</span><span class="s1">&#39;region&#39;</span><span class="p">][</span><span class="s1">&#39;unitsWH&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;base_pixels&#39;</span>
        <span class="n">pixel</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># This could be</span>
        <span class="c1">#  img, format = self.getRegion(format=TILE_FORMAT_PIL, **regionArgs)</span>
        <span class="c1"># where img is the PIL image (rather than tile[&#39;tile&#39;], but using</span>
        <span class="c1"># _tileIteratorInfo and the _tileIterator is slightly more efficient.</span>
        <span class="n">iterInfo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tileIteratorInfo</span><span class="p">(</span><span class="nb">format</span><span class="o">=</span><span class="n">TILE_FORMAT_PIL</span><span class="p">,</span> <span class="o">**</span><span class="n">regionArgs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">iterInfo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tile</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tileIterator</span><span class="p">(</span><span class="n">iterInfo</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">includeTileRecord</span><span class="p">:</span>
                <span class="n">pixel</span><span class="p">[</span><span class="s1">&#39;tile&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tile</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">tile</span><span class="p">[</span><span class="s1">&#39;tile&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">img</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">img</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">pixel</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">mode</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span> <span class="n">img</span><span class="o">.</span><span class="n">load</span><span class="p">()[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])))</span>
        <span class="k">return</span> <span class="n">pixel</span></div></div>


<div class="viewcode-block" id="FileTileSource"><a class="viewcode-back" href="../../../large_image/large_image.tilesource.html#large_image.tilesource.base.FileTileSource">[docs]</a><span class="k">class</span> <span class="nc">FileTileSource</span><span class="p">(</span><span class="n">TileSource</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the tile class.  See the base class for other available</span>
<span class="sd">        parameters.</span>

<span class="sd">        :param path: a filesystem path for the tile source.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">largeImagePath</span> <span class="o">=</span> <span class="n">path</span>

<div class="viewcode-block" id="FileTileSource.getLRUHash"><a class="viewcode-back" href="../../../large_image/large_image.tilesource.html#large_image.tilesource.base.FileTileSource.getLRUHash">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">getLRUHash</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">strhash</span><span class="p">(</span>
            <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;encoding&#39;</span><span class="p">,</span> <span class="s1">&#39;JPEG&#39;</span><span class="p">),</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;jpegQuality&#39;</span><span class="p">,</span> <span class="mi">95</span><span class="p">),</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;jpegSubsampling&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;tiffCompression&#39;</span><span class="p">,</span> <span class="s1">&#39;raw&#39;</span><span class="p">),</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;edge&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span>
            <span class="s1">&#39;__STYLESTART__&#39;</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;style&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="s1">&#39;__STYLEEND__&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="FileTileSource.getState"><a class="viewcode-back" href="../../../large_image/large_image.tilesource.html#large_image.tilesource.base.FileTileSource.getState">[docs]</a>    <span class="k">def</span> <span class="nf">getState</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_classkey&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_classkey</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">,</span><span class="si">%s</span><span class="s1">,</span><span class="si">%s</span><span class="s1">,</span><span class="si">%s</span><span class="s1">,</span><span class="si">%s</span><span class="s1">,</span><span class="si">%s</span><span class="s1">,__STYLESTART__,</span><span class="si">%s</span><span class="s1">,__STYLE_END__&#39;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_getLargeImagePath</span><span class="p">(),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">encoding</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">jpegQuality</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">jpegSubsampling</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tiffCompression</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">edge</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_jsonstyle</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_getLargeImagePath</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">largeImagePath</span>

<div class="viewcode-block" id="FileTileSource.canRead"><a class="viewcode-back" href="../../../large_image/large_image.tilesource.html#large_image.tilesource.base.FileTileSource.canRead">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">canRead</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if we can read the input.  This takes the same parameters as</span>
<span class="sd">        __init__.</span>

<span class="sd">        :returns: True if this class can read the input.  False if it</span>
<span class="sd">                  cannot.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">cls</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">except</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">TileSourceError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span></div></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright Kitware, Inc..</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>